---
phase: quick-02
plan: 04
type: execute
wave: 1
depends_on: []
files_modified:
  - offchain/src/lib/providers/akash-fetcher.ts
  - offchain/src/lib/agent/agent.ts
autonomous: true
requirements: ["QUICK-02-AGENT-E2E"]
gap_closure: true

must_haves:
  truths:
    - "Agent routes a job and displays thinking steps progressively"
    - "Result card shows selected Akash provider with details and reasoning"
    - "Demo works when live Akash API is unavailable (network/downtime)"
  artifacts:
    - path: "offchain/src/lib/providers/akash-fetcher.ts"
      provides: "Akash provider fetch with mock fallback"
      contains: "MOCK_PROVIDERS"
    - path: "offchain/src/lib/agent/agent.ts"
      provides: "Routing agent with fetch-vs-filter error distinction"
  key_links:
    - from: "offchain/src/lib/agent/agent.ts"
      to: "offchain/src/lib/providers/akash-fetcher.ts"
      via: "fetchAkashProviders() call — must never return empty silently"
      pattern: "fetchAkashProviders"
---

<objective>
Fix agent routing failure caused by live Akash API unavailability. When both Akash API endpoints fail, the fetcher silently returns [] — causing a misleading "No providers match requirements" error that blocks the entire demo.

Purpose: Demo must work reliably for hackathon presentation regardless of Akash API uptime.
Output: fetchAkashProviders returns mock providers as fallback; agent distinguishes fetch failure from filter failure in error messages.
</objective>

<execution_context>
@/home/julius/.claude/get-shit-done/workflows/execute-plan.md
@/home/julius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/quick/2-create-google-adk-agent-with-google-ai-s/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add mock provider fallback to akash-fetcher</name>
  <files>offchain/src/lib/providers/akash-fetcher.ts</files>
  <action>
At the top of akash-fetcher.ts (after the SynapseProvider interface, before fetchAkashProviders), add a MOCK_PROVIDERS constant — an array of 5 realistic SynapseProvider objects with source: 'Akash'. Include a spread of GPU models (A100, H100, RTX4090, RTX3090, V100), believable prices ($0.55–$4.20/hr), regions like "US", "EU", "Singapore", uptime values between 97–100%, and realistic GPU counts (1–4).

Then, in fetchAkashProviders(), replace the two silent-return-empty paths with fallback behavior:

1. Lines 190-193 (all endpoints failed): Instead of `return []`, log a warning "Akash API unavailable — using mock providers for demo" and `return MOCK_PROVIDERS`.

2. Lines 200-203 (empty/invalid response body): Instead of `return []`, log a warning "Akash API returned no providers — using mock providers for demo" and `return MOCK_PROVIDERS`.

3. Lines 297-300 (catch block): Instead of `return []`, log `console.error('Error fetching Akash providers:', error)` and `return MOCK_PROVIDERS`.

The 5 mock providers should have these shapes (adapt ids/names to be descriptive):
- { id: 'mock-akash-a100-us', name: 'Akash Node US-East-1', source: 'Akash', hardware: { gpuModel: 'NVIDIA A100', gpuCount: 4, cpuUnits: 128000, memory: 549755813888 }, priceEstimate: 2.50, region: 'US', uptimePercentage: 99.8 }
- { id: 'mock-akash-h100-eu', name: 'Akash Node EU-West-2', source: 'Akash', hardware: { gpuModel: 'NVIDIA H100', gpuCount: 2, cpuUnits: 64000, memory: 274877906944 }, priceEstimate: 4.20, region: 'EU', uptimePercentage: 99.5 }
- { id: 'mock-akash-rtx4090-sg', name: 'Akash Node SG-1', source: 'Akash', hardware: { gpuModel: 'NVIDIA RTX4090', gpuCount: 2, cpuUnits: 32000, memory: 137438953472 }, priceEstimate: 0.80, region: 'Singapore', uptimePercentage: 98.2 }
- { id: 'mock-akash-rtx3090-us', name: 'Akash Node US-West-1', source: 'Akash', hardware: { gpuModel: 'NVIDIA RTX3090', gpuCount: 1, cpuUnits: 16000, memory: 68719476736 }, priceEstimate: 0.55, region: 'US', uptimePercentage: 97.1 }
- { id: 'mock-akash-v100-eu', name: 'Akash Node EU-Central-1', source: 'Akash', hardware: { gpuModel: 'NVIDIA V100', gpuCount: 2, cpuUnits: 32000, memory: 137438953472 }, priceEstimate: 1.50, region: 'EU', uptimePercentage: 99.0 }

Do NOT add a isMock field or any other field beyond the SynapseProvider interface.
  </action>
  <verify>
Run: cd /home/julius/Documents/necto/offchain && npx tsc --noEmit
No TypeScript errors.
  </verify>
  <done>fetchAkashProviders never returns [] — it always returns either live Akash providers or the 5 mock providers. TypeScript compiles cleanly.</done>
</task>

<task type="auto">
  <name>Task 2: Distinguish fetch failure from filter failure in agent error messages</name>
  <files>offchain/src/lib/agent/agent.ts</files>
  <action>
After the fetchAkashProviders() call in routeComputeJob (around line 51), add a check that distinguishes zero providers fetched (upstream failure, even after fallback) from zero providers after filtering (requirements too strict):

```typescript
// After: const providers = await fetchAkashProviders()
// After the id:1 complete thinking step

if (providers.length === 0) {
  throw new Error('Provider fetch failed — no providers available from Akash Network or fallback')
}
```

Then, replace the existing check at line 88-90:
```typescript
if (rankedProviders.length === 0) {
  throw new Error('No providers match the job requirements')
}
```
with:
```typescript
if (rankedProviders.length === 0) {
  throw new Error(
    `No providers match requirements after filtering ${providers.length} available providers. ` +
    `Try relaxing constraints: raise max price, remove GPU model filter, or clear region.`
  )
}
```

This gives users actionable guidance when they over-constrain their job (e.g., maxPrice: 0.01, gpuModel: H100 — which would filter out all providers including mocks).
  </action>
  <verify>
Run: cd /home/julius/Documents/necto/offchain && npx tsc --noEmit
No TypeScript errors.

Then run: npm run build
Build passes with no errors.
  </verify>
  <done>Agent distinguishes between "fetch failure" and "filter failure" with distinct error messages. Build passes cleanly. Submitting "Train a BERT model" with GPU "Any" and no other filters routes successfully through mock providers when live API is down.</done>
</task>

</tasks>

<verification>
1. `cd /home/julius/Documents/necto/offchain && npm run build` — clean build, no errors
2. Start dev server: `npm run dev`
3. Visit http://localhost:3000/verify-agent
4. Submit: description="Train a BERT model", GPU=Any, no other constraints
5. Expected: Thinking steps appear, result card shows a provider (mock or live)
6. Even if Akash live API is down: same result using mock providers
</verification>

<success_criteria>
- fetchAkashProviders always returns >= 5 providers (mocks) when live API is unavailable
- "Train a BERT model" with default constraints always produces a routing result, never an error
- TypeScript compiles clean, Next.js build passes
- Agent error messages distinguish fetch failure from filter failure with actionable guidance
</success_criteria>

<output>
After completion, create `.planning/quick/2-create-google-adk-agent-with-google-ai-s/02-04-SUMMARY.md` using the summary template.
</output>
