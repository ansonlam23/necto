---
phase: 01-core-infrastructure
plan: 09
type: execute
wave: 4
depends_on: ["01-01"]
files_modified:
  - scripts/deploy.ts
  - scripts/verify.ts
  - .env
  - src/config/contracts.ts
  - CONTRACTS.md
autonomous: false
user_setup:
  - service: 0g-chain
    why: "Deploy ComputeRouter.sol to ADI Testnet"
    env_vars:
      - name: PRIVATE_KEY
        source: "Generate new wallet - fund from 0G faucet"
      - name: USDC_TOKEN_ADDRESS
        source: "Optional: Use existing testnet USDC. If unset, deploys MockUSDC automatically"
    dashboard_config:
      - task: "Get testnet A0G tokens from faucet"
        location: "https://faucet.0g.ai or 0G Discord"
      - task: "Deploy contracts to ADI Testnet"
        location: "Run: npx hardhat run scripts/deploy.ts --network 0g-testnet"
      - task: "Check for existing testnet USDC (optional)"
        location: "0G Chain explorer or docs - if exists, set USDC_TOKEN_ADDRESS env var"

must_haves:
  truths:
    - "ComputeRouter.sol deployed to ADI Testnet with verified address"
    - "Provider registry functions work on-chain"
    - "Job creation locks USDC in escrow contract"
    - "Job completion releases payment to provider"
    - "Contract ABI available for frontend integration"
  artifacts:
    - path: "scripts/deploy.ts"
      provides: "Deployment script for ADI Testnet"
      exports: ["deployContracts"]
    - path: "src/config/contracts.ts"
      provides: "Deployed contract addresses"
      exports: ["CONTRACT_ADDRESSES", "ComputeRouterABI"]
    - path: "CONTRACTS.md"
      provides: "Deployment documentation"
  key_links:
    - from: "Frontend"
      to: "ComputeRouter on ADI Testnet"
      via: "ethers.js contract interaction"
    - from: "Job creation"
      to: "Escrow contract"
      via: "USDC transferFrom buyer to escrow"
---

<objective>
Deploy ComputeRouter.sol and supporting contracts to ADI Testnet (0G Chain), verify functionality, and document deployment for frontend integration. Implements ADI-01 through ADI-04.

Purpose: Make smart contracts live on testnet for real escrow and job registry functionality.
Output: Deployed contract addresses, verified deployment, and integration configuration.
</objective>

<execution_context>
@/home/julius/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/julius/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-core-infrastructure/01-CONTEXT.md
@.planning/phases/01-core-infrastructure/01-RESEARCH.md
@.planning/phases/01-core-infrastructure/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Prepare deployment scripts and MockUSDC</name>
  <files>scripts/deploy.ts, contracts/MockUSDC.sol</files>
  <action>
    Create deployment infrastructure and mock token:
    1. Create `contracts/MockUSDC.sol` (for testing):
       ```solidity
       // SPDX-License-Identifier: MIT
       pragma solidity ^0.8.19;
       
       import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
       
       contract MockUSDC is ERC20 {
           constructor() ERC20("Mock USDC", "mUSDC") {
               _mint(msg.sender, 1000000 * 10**6); // 1M USDC with 6 decimals
           }
           
           function decimals() public pure override returns (uint8) {
               return 6;
           }
           
           function mint(address to, uint256 amount) external {
               _mint(to, amount);
           }
       }
       ```
    2. Update `scripts/deploy.ts`:
       ```typescript
       import { ethers } from 'hardhat'
       import * as fs from 'fs'
       import * as path from 'path'
       
       async function deployContracts() {
          console.log('Deploying to ADI Testnet...')
          
          // Check for existing USDC on testnet first, deploy MockUSDC if needed
          // NOTE: If testnet has official USDC, set USDC_TOKEN_ADDRESS env var to use it
          let usdcAddress: string
          if (process.env.USDC_TOKEN_ADDRESS) {
            usdcAddress = process.env.USDC_TOKEN_ADDRESS
            console.log('Using existing USDC at:', usdcAddress)
          } else {
            console.log('Deploying MockUSDC (fallback for testing)...')
            const MockUSDC = await ethers.getContractFactory('MockUSDC')
            const mockUSDC = await MockUSDC.deploy()
            await mockUSDC.waitForDeployment()
            usdcAddress = await mockUSDC.getAddress()
            console.log('✓ MockUSDC deployed:', usdcAddress)
            console.log('  Note: Set USDC_TOKEN_ADDRESS env var to use real testnet USDC')
          }
         
         // Deploy ProviderRegistry
         console.log('Deploying ProviderRegistry...')
         const ProviderRegistry = await ethers.getContractFactory('ProviderRegistry')
         const providerRegistry = await ProviderRegistry.deploy()
         await providerRegistry.waitForDeployment()
         const registryAddress = await providerRegistry.getAddress()
         console.log('✓ ProviderRegistry deployed:', registryAddress)
         
         // Deploy JobRegistry
         console.log('Deploying JobRegistry...')
         const JobRegistry = await ethers.getContractFactory('JobRegistry')
         const jobRegistry = await JobRegistry.deploy()
         await jobRegistry.waitForDeployment()
         const jobRegistryAddress = await jobRegistry.getAddress()
         console.log('✓ JobRegistry deployed:', jobRegistryAddress)
         
         // Deploy Escrow
         console.log('Deploying Escrow...')
         const Escrow = await ethers.getContractFactory('Escrow')
         const escrow = await Escrow.deploy(usdcAddress)
         await escrow.waitForDeployment()
         const escrowAddress = await escrow.getAddress()
         console.log('✓ Escrow deployed:', escrowAddress)
         
         // Deploy ComputeRouter (main contract)
         console.log('Deploying ComputeRouter...')
         const ComputeRouter = await ethers.getContractFactory('ComputeRouter')
         const computeRouter = await ComputeRouter.deploy(
           registryAddress,
           jobRegistryAddress,
           escrowAddress,
           usdcAddress
         )
         await computeRouter.waitForDeployment()
         const routerAddress = await computeRouter.getAddress()
         console.log('✓ ComputeRouter deployed:', routerAddress)
         
         // Set permissions
         console.log('Setting up permissions...')
         await providerRegistry.transferOwnership(routerAddress)
         await jobRegistry.transferOwnership(routerAddress)
         await escrow.transferOwnership(routerAddress)
         console.log('✓ Permissions set')
         
         // Save deployment info
         const deploymentInfo = {
           network: '0g-testnet',
           chainId: 16602,
           timestamp: new Date().toISOString(),
           contracts: {
             MockUSDC: usdcAddress,
             ProviderRegistry: registryAddress,
             JobRegistry: jobRegistryAddress,
             Escrow: escrowAddress,
             ComputeRouter: routerAddress
           }
         }
         
         const deploymentPath = path.join(__dirname, '..', 'deployments')
         if (!fs.existsSync(deploymentPath)) {
           fs.mkdirSync(deploymentPath)
         }
         
         fs.writeFileSync(
           path.join(deploymentPath, '0g-testnet.json'),
           JSON.stringify(deploymentInfo, null, 2)
         )
         
         console.log('\n✅ Deployment complete!')
         console.log('Deployment info saved to deployments/0g-testnet.json')
         
         return deploymentInfo
       }
       
       deployContracts().catch((error) => {
         console.error(error)
         process.exit(1)
       })
       ```
    3. Create `scripts/verify.ts` to test deployment:
       ```typescript
       // Verification script to test contract functionality
       import { ethers } from 'hardhat'
       import deploymentInfo from '../deployments/0g-testnet.json'
       
       async function verifyDeployment() {
         console.log('Verifying deployment...')
         
         const [signer] = await ethers.getSigners()
         const router = await ethers.getContractAt(
           'ComputeRouter',
           deploymentInfo.contracts.ComputeRouter
         )
         
         // Test 1: Register provider
         console.log('Testing provider registration...')
         const tx1 = await router.registerProvider('https://example.com/metadata')
         await tx1.wait()
         console.log('✓ Provider registered')
         
         // Test 2: Create job
         console.log('Testing job creation...')
         // Approve USDC first
         const usdc = await ethers.getContractAt('MockUSDC', deploymentInfo.contracts.MockUSDC)
         await usdc.approve(deploymentInfo.contracts.ComputeRouter, 1000000)
         
         const tx2 = await router.createJob(
           signer.address, // provider
           true, // tracked mode
           '0x1234...', // reasoning hash
           100000 // amount (0.1 USDC)
         )
         const receipt = await tx2.wait()
         console.log('✓ Job created, tx:', receipt?.hash)
         
         // Test 3: Get job details
         // Extract jobId from event...
         
         console.log('\n✅ Verification complete!')
       }
       
       verifyDeployment().catch(console.error)
       ```
    4. Install OpenZeppelin contracts:
       ```bash
       npm install @openzeppelin/contracts
       ```
    
    This prepares everything for actual deployment.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit scripts/deploy.ts`
    Contracts compile: `npx hardhat compile`
  </verify>
  <done>
    Deployment scripts ready with MockUSDC and full contract suite
  </done>
</task>

<task type="checkpoint:human-action">
  <name>Task 2: Fund wallet and deploy to ADI Testnet</name>
  <files>depployments/0g-testnet.json, .env</files>
  <decision>Deploy ComputeRouter to ADI Testnet (0G Chain)</decision>
  <context>
    This requires human action because:
    1. Need to create/fund a wallet on 0G Testnet
    2. Need to keep private key secure (don't commit to git)
    3. ADI Testnet = 0G Galileo testnet (Chain ID 16602)
    
    Contract deployment costs ~0.01 A0G tokens (very cheap).
  </context>
  <action_required>
    1. **Create wallet (if needed):**
       ```bash
       npx hardhat node
       # Or use existing wallet
       ```
    
    2. **Get testnet A0G tokens:**
       - Visit: https://faucet.0g.ai
       - Or join 0G Discord and request in #faucet channel
       - Provide your wallet address
       - Wait for tokens (usually instant)
    
    3. **Set environment variables:**
       ```bash
       export PRIVATE_KEY="your_private_key_here"
       ```
    
    4. **Run deployment:**
       ```bash
       npx hardhat run scripts/deploy.ts --network 0g-testnet
       ```
    
    5. **Verify deployment:**
       ```bash
       npx hardhat run scripts/verify.ts --network 0g-testnet
       ```
  </action_required>
  <verify>
    Check deployments/0g-testnet.json exists with all contract addresses
    Verify on 0G explorer: https://chainscan-galileo.0g.ai
  </verify>
  <resume-signal>
    Type "deployed" once contracts are live on testnet with addresses saved
  </resume-signal>
</task>

<task type="auto">
  <name>Task 3: Configure frontend contract integration</name>
  <files>src/config/contracts.ts, CONTRACTS.md, .env.example</files>
  <action>
    Configure frontend to use deployed contracts:
    1. Create `src/config/contracts.ts`:
       ```typescript
       // Contract addresses and ABIs for frontend
       import ComputeRouterABI from '../../artifacts/contracts/ComputeRouter.sol/ComputeRouter.json'
       import MockUSDCABI from '../../artifacts/contracts/MockUSDC.sol/MockUSDC.json'
       
       export interface ContractConfig {
         address: string
         abi: any
         chainId: number
       }
       
       export const CONTRACT_ADDRESSES: Record&lt;number, {
         computeRouter: string
         mockUSDC: string
         providerRegistry: string
       }&gt; = {
         16602: { // 0G Testnet
           computeRouter: process.env.NEXT_PUBLIC_COMPUTE_ROUTER || '',
           mockUSDC: process.env.NEXT_PUBLIC_MOCK_USDC || '',
           providerRegistry: process.env.NEXT_PUBLIC_PROVIDER_REGISTRY || ''
         }
       }
       
       export { ComputeRouterABI, MockUSDCABI }
       
       export function getContractConfig(
         chainId: number,
         contractType: 'computeRouter' | 'mockUSDC'
       ): ContractConfig {
         const addresses = CONTRACT_ADDRESSES[chainId]
         if (!addresses) {
           throw new Error(`No contracts configured for chain ${chainId}`)
         }
         
         return {
           address: addresses[contractType],
           abi: contractType === 'computeRouter' ? ComputeRouterABI.abi : MockUSDCABI.abi,
           chainId
         }
       }
       ```
    2. Update `.env.example` with contract addresses:
       ```
       # Contract Addresses (after deployment)
       NEXT_PUBLIC_COMPUTE_ROUTER=0x...
       NEXT_PUBLIC_MOCK_USDC=0x...
       NEXT_PUBLIC_PROVIDER_REGISTRY=0x...
       ```
    3. Create `CONTRACTS.md` documentation:
       ```markdown
       # Smart Contract Deployment
       
       ## ADI Testnet (0G Chain)
       
       **Network:** 0G Galileo Testnet  
       **Chain ID:** 16602  
       **RPC:** https://evmrpc-testnet.0g.ai  
       **Explorer:** https://chainscan-galileo.0g.ai
       
       ### Deployed Contracts
       
       | Contract | Address | Purpose |
       |----------|---------|---------|
       | ComputeRouter | [0x...](...) | Main contract for jobs and escrow |
       | MockUSDC | [0x...](...) | Test USDC token |
       | ProviderRegistry | [0x...](...) | Provider listings |
       
       ### ABI Files
       
       Located in `artifacts/contracts/` after compilation.
       
       ### Functions
       
       #### Provider Management
       - `registerProvider(string metadataURI)` - List as compute provider
       - `updateProviderStatus(bool isActive)` - Toggle availability
       
       #### Job Lifecycle
       - `createJob(address provider, bool tracked, string reasoningHash, uint256 amount)` - Create job with escrow
       - `completeJob(bytes32 jobId)` - Release payment to provider
       
       #### View Functions
       - `getProvider(address owner)` - Get provider details
       - `getJob(bytes32 jobId)` - Get job details
       - `getEscrow(bytes32 jobId)` - Get escrow status
       ```
    4. Copy ABIs to accessible location (if needed for frontend build)
    5. Update wagmi config to include 0G testnet:
       ```typescript
       // In src/lib/wagmi.ts
       import { defineChain } from 'viem'
       
       export const zeroGTestnet = defineChain({
         id: 16602,
         name: '0G Testnet',
         nativeCurrency: { name: 'A0G', symbol: 'A0G', decimals: 18 },
         rpcUrls: {
           default: { http: ['https://evmrpc-testnet.0g.ai'] }
         },
         blockExplorers: {
           default: { name: '0G Explorer', url: 'https://chainscan-galileo.0g.ai' }
         }
       })
       ```
    
    This makes contracts accessible to the Next.js frontend.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/config/contracts.ts`
    ABIs load correctly from artifacts
  </verify>
  <done>
    Frontend contract configuration created with ABIs and addresses
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Contracts deployed to ADI Testnet with verified addresses
2. Deployment info saved to deployments/0g-testnet.json
3. Frontend can interact with contracts via wagmi/ethers
4. Provider registration works on-chain
5. Job creation with USDC escrow works
</verification>

<success_criteria>
- ComputeRouter.sol deployed to ADI Testnet (0G Chain, Chain ID 16602)
- MockUSDC deployed for testing (or real testnet USDC if available)
- ProviderRegistry tracks provider registrations on-chain
- JobRegistry stores job records with Tracked/Untracked flag
- Escrow contract holds USDC and releases on completion
- Frontend configuration includes contract addresses and ABIs
- wagmi config updated with 0G testnet chain
- Deployment documented in CONTRACTS.md
- Contract addresses in environment variables (not committed)
- Provider can register via contract call
- Buyer can create job with USDC escrow
- Job completion releases payment to provider
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-09-SUMMARY.md`
</output>
