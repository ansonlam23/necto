---
phase: 01-core-infrastructure
plan: 03
type: execute
wave: 1
depends_on: ["01-02"]
files_modified:
  - src/providers/base.ts
  - src/providers/akash.ts
  - src/providers/lambda.ts
  - src/providers/filecoin.ts
  - src/providers/ionet.ts
  - src/providers/mock.ts
  - src/lib/provider-registry.ts
autonomous: true

must_haves:
  truths:
    - "Provider adapter interface abstracts all provider-specific APIs"
    - "6-8 providers are available including Akash, Lambda, Filecoin, io.net"
    - "Mock providers provide realistic hardcoded data for demo"
    - "Provider registry can list all providers and filter by capabilities"
    - "Each provider returns quotes in common format via getQuotes()"
  artifacts:
    - path: "src/providers/base.ts"
      provides: "Abstract provider adapter interface"
      exports: ["ProviderAdapter", "QuoteRequest", "QuoteResult"]
    - path: "src/providers/akash.ts"
      provides: "Akash Network provider adapter"
      exports: ["AkashProvider"]
    - path: "src/providers/lambda.ts"
      provides: "Lambda Labs provider adapter"
      exports: ["LambdaProvider"]
    - path: "src/providers/filecoin.ts"
      provides: "Filecoin FVM provider adapter"
      exports: ["FilecoinProvider"]
    - path: "src/providers/ionet.ts"
      provides: "io.net provider adapter"
      exports: ["IonetProvider"]
    - path: "src/providers/mock.ts"
      provides: "Mock providers for Synapse-listed orgs"
      exports: ["MockProvider"]
    - path: "src/lib/provider-registry.ts"
      provides: "Provider discovery and filtering"
      exports: ["ProviderRegistry", "getAllProviders", "filterProviders"]
  key_links:
    - from: "AkashProvider"
      to: "ProviderAdapter"
      via: "implements interface"
    - from: "ProviderRegistry"
      to: "ProviderAdapter"
      via: "registry contains provider instances"
---

<objective>
Implement the Provider Adapter Pattern to abstract multiple compute provider APIs behind a common interface. Create adapters for Akash, Lambda Labs, Filecoin, io.net, and mock providers for the demo.

Purpose: Enable the agent to query any provider using the same interface, supporting AGENT-01 (multi-provider aggregation).
Output: Provider adapter implementations and registry for discovering/filtering providers.
</objective>

<execution_context>
@/home/julius/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/julius/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-core-infrastructure/01-CONTEXT.md
@.planning/phases/01-core-infrastructure/01-RESEARCH.md
@.planning/phases/01-core-infrastructure/01-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create base provider adapter interface</name>
  <files>src/providers/base.ts</files>
  <action>
    Create the abstract provider adapter interface:
    1. Create `src/providers/base.ts` with:
       - `QuoteRequest` interface:
         * gpuType: GpuType
         * gpuCount: number
         * durationHours: number
         * region?: string
         * useSpot?: boolean
       - `QuoteResult` interface:
         * providerId: string
         * quotes: PriceQuote[]
         * latencyMs: number (simulated or real)
         * fetchedAt: Date
         * error?: string
       - `ProviderAdapter` abstract class/interface:
         * readonly id: string
         * readonly name: string
         * readonly type: ProviderType
         * readonly capabilities: ProviderCapabilities
         * abstract getQuotes(request: QuoteRequest): Promise&lt;QuoteResult&gt;
         * abstract getProviderInfo(): ComputeProvider
         * abstract isAvailable(): Promise&lt;boolean&gt;
       - `ProviderError` class for standardized error handling:
         * code: 'UNAVAILABLE' | 'RATE_LIMIT' | 'INVALID_REQUEST' | 'UNKNOWN'
         * message: string
         * providerId: string
    2. Add helper functions:
       - `calculateLatency(providerRegion: string, targetRegion: string): number`
       - `isGpuAvailable(provider: ProviderCapabilities, gpuType: GpuType): boolean`
    3. Export all types and the base class
    
    Design for extension: New providers implement ProviderAdapter.
    Per research: Abstract provider APIs behind common interface to handle API changes gracefully.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/providers/base.ts`
  </verify>
  <done>
    Base ProviderAdapter interface created with QuoteRequest, QuoteResult, and error handling
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Akash and Lambda provider adapters</name>
  <files>src/providers/akash.ts, src/providers/lambda.ts</files>
  <action>
    Implement real provider adapters (with mocked data for hackathon):
    1. Create `src/providers/akash.ts`:
       - Implement `AkashProvider` class extending ProviderAdapter
       - Constructor sets id='akash', name='Akash Network', type='akash'
       - Capabilities: Supports SPOT and FIXED pricing, multiple GPU types, global regions
       - getQuotes(): Return hardcoded realistic quotes for Akash:
         * A100: $1.50-2.50/hr (spot discount 30-50%)
         * V100: $0.80-1.20/hr
         * TOKEN pricing (AKT token, reference CoinGecko later)
       - Include 2-3 regions (us-west, eu-west, ap-south)
       - Simulate latency based on region distance
       - Add comments noting: "Live API integration deferred to post-hackathon"
    2. Create `src/providers/lambda.ts`:
       - Implement `LambdaProvider` class
       - Constructor sets id='lambda', name='Lambda Labs', type='lambda'
       - Capabilities: FIXED pricing only, high-performance GPUs, US regions
       - getQuotes(): Return hardcoded realistic Lambda pricing:
         * H100: $2.99/hr (fixed)
         * A100 80GB: $1.99/hr
         * A10: $0.60/hr
       - Include us-east and us-west regions
       - Lower latency (premium provider)
    3. Both providers:
       - Implement isAvailable() returning true for demo
       - Return realistic quote structures matching PriceQuote type
       - Add proper error handling with ProviderError
    
    Per user decision: Use hardcoded realistic data (no live APIs for hackathon).
    Per research: Akash SDK (@akashnetwork/akashjs) noted but using mock data for now.
  </action>
  <verify>
    Both providers compile and export correctly
  </verify>
  <done>
    Akash and Lambda provider adapters implemented with realistic hardcoded pricing
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Filecoin, io.net, and mock providers</name>
  <files>src/providers/filecoin.ts, src/providers/ionet.ts, src/providers/mock.ts</files>
  <action>
    Implement remaining provider adapters:
    1. Create `src/providers/filecoin.ts`:
       - Implement `FilecoinProvider` class
       - id='filecoin', name='Filecoin (FVM)', type='filecoin'
       - Capabilities: TOKEN pricing (FIL), storage-optimized
       - getQuotes(): Return hardcoded quotes:
         * A100: $1.80/hr + FIL token component
         * Include FIL/USD reference
       - Focus on storage + compute bundles
    2. Create `src/providers/ionet.ts`:
       - Implement `IonetProvider` class
       - id='ionet', name='io.net', type='ionet'
       - Capabilities: SPOT pricing, consumer GPUs
       - getQuotes(): Return hardcoded quotes:
         * RTX4090: $0.45/hr (spot)
         * RTX3090: $0.35/hr
       - Emphasize consumer GPU affordability
    3. Create `src/providers/mock.ts` for Synapse-listed providers:
       - Implement `MockProvider` class that takes config in constructor
       - Create 3-4 mock Synapse providers with different positioning:
         * "Vertex Compute": Budget-focused, T4/V100, $0.20-0.60/hr
         * "Nebula Cloud": Premium H100s, $2.50-3.50/hr
         * "Quantum Labs": Balanced A100s, $1.80-2.20/hr
         * "Stellar Nodes": Europe-focused, competitive EU pricing
       - Each with unique capabilities and regions
       - Use to demonstrate diversity in marketplace
    4. All providers implement full ProviderAdapter interface
    
    Total providers: Akash + Lambda + Filecoin + io.net + 4 mocks = 8 providers âœ“
    Per requirement: 6-8 providers including 2-3 Synapse-listed.
  </action>
  <verify>
    All provider files compile without errors
  </verify>
  <done>
    Filecoin, io.net, and 4 mock Synapse providers implemented (8 total)
  </done>
</task>

<task type="auto">
  <name>Task 4: Create provider registry and discovery</name>
  <files>src/lib/provider-registry.ts</files>
  <action>
    Create provider registry for discovery and filtering:
    1. Create `src/lib/provider-registry.ts` with:
       - `ProviderRegistry` class:
         * providers: Map&lt;string, ProviderAdapter&gt;
         * register(provider: ProviderAdapter): void
         * unregister(providerId: string): void
         * get(providerId: string): ProviderAdapter | undefined
         * getAll(): ProviderAdapter[]
         * filter(criteria: FilterCriteria): ProviderAdapter[]
       - `FilterCriteria` interface:
         * gpuType?: GpuType
         * regions?: string[]
         * pricingModels?: PricingModel[]
         * minReputation?: number
         * requireSpot?: boolean
       - `getAllProviders()` function:
         * Instantiates all 8 providers (Akash, Lambda, Filecoin, io.net, 4 mocks)
         * Returns array of initialized adapters
         * Logs provider count and types
       - `filterProviders()` function:
         * Takes providers array and FilterCriteria
         * Returns filtered array matching all criteria
         * Handles undefined criteria gracefully
       - Helper functions:
         * `getProvidersByRegion(region: string): ProviderAdapter[]`
         * `getProvidersByGpu(gpuType: GpuType): ProviderAdapter[]`
         * `getProviderRegions(): string[]` (unique regions across providers)
    2. Add initialization:
       - `initializeRegistry(): ProviderRegistry` that pre-populates with all 8 providers
       - Export singleton instance: `export const registry = initializeRegistry()`
    3. Export all functions and the registry
    
    Per user decision: Ignore capacity constraints for hackathon (all providers always available).
    This implements the provider discovery foundation for AGENT-01.
  </action>
  <verify>
    Registry compiles and can be imported: `npx tsc --noEmit src/lib/provider-registry.ts`
  </verify>
  <done>
    Provider registry created with filtering, discovery, and all 8 providers pre-registered
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. All provider adapters compile and implement ProviderAdapter
2. Provider registry returns all 8 providers
3. Filtering works by GPU type, region, and pricing model
4. Each provider returns realistic hardcoded quotes
</verification>

<success_criteria>
- ProviderAdapter base interface abstracts all provider implementations
- 8 provider adapters implemented (Akash, Lambda, Filecoin, io.net, 4 mocks)
- Each provider returns quotes in common PriceQuote format
- Provider registry supports filtering by GPU, region, pricing model
- Hardcoded realistic pricing data for all providers
- Synapse-listed providers (mocks) demonstrate marketplace diversity
- All providers implement error handling with ProviderError
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-03-SUMMARY.md`
</output>
