---
phase: 01-core-infrastructure
plan: 08
type: execute
wave: 4
depends_on: ["01-04", "01-05", "01-06", "01-07"]
files_modified:
  - src/lib/agent/orchestrator.ts
  - src/lib/agent/index.ts
  - src/app/api/agent/route.ts
autonomous: true

must_haves:
  truths:
    - "Orchestrator coordinates all agent modules end-to-end"
    - "Job submission triggers full pipeline: filter → score → rank → store"
    - "Reasoning trace uploaded to 0G and hash returned"
    - "Top 3 recommendations returned with pricing and tradeoffs"
    - "Both Tracked and Untracked modes work through orchestrator"
  artifacts:
    - path: "src/lib/agent/orchestrator.ts"
      provides: "Agent orchestration and coordination"
      exports: ["AgentOrchestrator", "processJobRequest"]
    - path: "src/lib/agent/index.ts"
      provides: "Agent module public API"
      exports: ["agent", "submitJob", "getRecommendations"]
    - path: "src/app/api/agent/route.ts"
      provides: "HTTP API for agent"
      exports: ["POST /api/agent"]
  key_links:
    - from: "AgentOrchestrator"
      to: "Ranker"
      via: "calls rankProviders() for recommendations"
    - from: "AgentOrchestrator"
      to: "storageService"
      via: "uploads reasoning trace to 0G"
    - from: "AgentOrchestrator"
      to: "PriceNormalizer"
      via: "normalizes all provider quotes"
    - from: "processJobRequest"
      to: "identityService"
      via: "handles Tracked/Untracked mode"
---

<objective>
Assemble all agent modules into a unified orchestrator that coordinates the full pipeline: identity handling, provider filtering, price normalization, ranking, and 0G storage upload. Creates the public API for job processing.

Purpose: Provide a single entry point for the agent that wires together all components.
Output: Agent orchestrator, public API exports, and HTTP endpoint for frontend integration.
</objective>

<execution_context>
@/home/julius/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/julius/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-core-infrastructure/01-CONTEXT.md
@.planning/phases/01-core-infrastructure/01-RESEARCH.md
@.planning/phases/01-core-infrastructure/01-04-SUMMARY.md
@.planning/phases/01-core-infrastructure/01-05-SUMMARY.md
@.planning/phases/01-core-infrastructure/01-06-SUMMARY.md
@.planning/phases/01-core-infrastructure/01-07-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create agent orchestrator</name>
  <files>src/lib/agent/orchestrator.ts</files>
  <action>
    Build the main orchestrator that coordinates all modules:
    1. Create `src/lib/agent/orchestrator.ts`:
       - `AgentOrchestrator` class:
         * Constructor injects dependencies:
           - providerRegistry: ProviderRegistry
           - priceNormalizer: PriceNormalizer
           - ranker: Ranker
           - storageService: StorageService
           - identityService: IdentityService
         * async processJob(request: JobRequest): Promise&lt;JobResult&gt;:
           ```typescript
           // Full pipeline implementation
           const startTime = Date.now()
           
           // Step 1: Handle identity (AGENT-06)
           console.log('[Agent] Processing identity...')
           const identity = this.identityService.createIdentity({
             walletAddress: request.buyerAddress,
             organizationId: request.teamMemberId ? 'team-' + request.teamMemberId : undefined,
             teamMemberId: request.teamMemberId,
             mode: request.constraints.identityMode
           })
           
           // Step 2: Get all providers (AGENT-01)
           console.log('[Agent] Fetching providers...')
           const allProviders = this.providerRegistry.getAll()
           
           // Step 3: Filter by constraints (AGENT-04)
           console.log('[Agent] Filtering providers...')
           const filterResults = filterProviders(allProviders, request.constraints)
           const passedProviders = filterResults.filter(r =&gt; r.passed).map(r =&gt; r.provider)
           const rejectedProviders = filterResults.filter(r =&gt; !r.passed)
           
           // Step 4: Get quotes from passed providers
           console.log('[Agent] Getting quotes from', passedProviders.length, 'providers...')
           const quoteRequests = passedProviders.map(p =&gt; ({
             provider: p,
             request: {
               gpuType: request.constraints.requiredGpuType!,
               gpuCount: request.gpuCount,
               durationHours: request.durationHours,
               region: request.constraints.preferredRegions?.[0],
               useSpot: false
             }
           }))
           
           // Fetch quotes in parallel with timeout
           const quoteResults = await Promise.allSettled(
             quoteRequests.map(async ({ provider, request }) =&gt; {
               const adapter = this.providerRegistry.get(provider.id)
               if (!adapter) return null
               return await Promise.race([
                 adapter.getQuotes(request),
                 new Promise((_, reject) =&gt; 
                   setTimeout(() =&gt; reject(new Error('Timeout')), 5000)
                 )
               ])
             })
           )
           
           // Step 5: Normalize prices (AGENT-02, AGENT-03)
           console.log('[Agent] Normalizing prices...')
           const validQuotes: PriceQuote[] = []
           quoteResults.forEach((result, index) =&gt; {
             if (result.status === 'fulfilled' &amp;&amp; result.value) {
               validQuotes.push(...result.value.quotes)
             }
           })
           
           const normalizedPrices = await this.priceNormalizer.normalizeMultipleQuotes(
             validQuotes, 
             request
           )
           
           // Step 6: Rank providers (AGENT-05)
           console.log('[Agent] Ranking providers...')
           const rankingResult = this.ranker.rankProviders(
             passedProviders,
             normalizedPrices,
             request.constraints,
             request
           )
           
           // Step 7: Generate reasoning trace (0G-01)
           console.log('[Agent] Generating reasoning trace...')
           const trace = generateReasoningTrace({
             jobRequest: request,
             filterResults,
             scoredProviders: rankingResult.scoredProviders,
             topRecommendations: rankingResult.recommendations,
             weights: DEFAULT_WEIGHTS,
             duration: Date.now() - startTime
           })
           
           // Step 8: Upload to 0G Storage (0G-01, 0G-02)
           console.log('[Agent] Uploading to 0G...')
           let reasoningHash: string
           try {
             reasoningHash = await this.storageService.uploadReasoningTrace(trace)
             console.log('[Agent] Uploaded to 0G, hash:', reasoningHash)
           } catch (error) {
             console.error('[Agent] 0G upload failed:', error)
             reasoningHash = 'upload-failed-' + Date.now()
           }
           
           // Step 9: Build result
           const topRecommendation = rankingResult.recommendations[0]
           const jobResult: JobResult = {
             jobId: request.id,
             selectedProvider: topRecommendation.provider,
             normalizedPrice: topRecommendation.normalizedPrice,
             totalCost: topRecommendation.normalizedPrice.effectiveUsdPerA100Hour * 
                        request.durationHours * request.gpuCount,
             status: 'CONFIRMED',
             reasoningHash,
             createdAt: new Date(),
             recommendations: rankingResult.recommendations
           }
           
           console.log('[Agent] Job processed in', Date.now() - startTime, 'ms')
           return jobResult
           ```
         * Error handling:
           - Try-catch around entire pipeline
           - Log errors at each step
           - Return partial results if possible
           - Never crash — always return JobResult or throw structured error
       - Export orchestrator singleton:
         ```typescript
         export const orchestrator = new AgentOrchestrator(
           registry,
           priceNormalizer,
           ranker,
           storageService,
           identityService
         )
         ```
    2. Add performance monitoring:
       - Track duration of each pipeline step
       - Log provider count at each stage
       - Count successful/failed quote fetches
    3. Export all orchestrator types
    
    This is the core integration point — all previous modules come together here.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/lib/agent/orchestrator.ts`
    All dependencies resolve (registry, normalizer, ranker, storage, identity)
  </verify>
  <done>
    AgentOrchestrator implemented with full pipeline: identity → filter → quotes → normalize → rank → upload
  </done>
</task>

<task type="auto">
  <name>Task 2: Create public agent API and HTTP endpoint</name>
  <files>src/lib/agent/index.ts, src/app/api/agent/route.ts</files>
  <action>
    Create public API and HTTP endpoint for the agent:
    1. Create `src/lib/agent/index.ts`:
       - Re-export all agent modules:
         ```typescript
         // Core exports
         export * from './filter'
         export * from './scorer'
         export * from './ranker'
         export * from './reasoning'
         export * from './orchestrator'
         
         // Re-export with agent namespace
         export { orchestrator as agent }
         ```
       - Convenience functions:
         ```typescript
         export async function submitJob(request: JobRequest): Promise&lt;JobResult&gt; {
           return orchestrator.processJob(request)
         }
         
         export async function getRecommendations(
           constraints: JobConstraints
         ): Promise&lt;ProviderRecommendation[]&gt; {
           const mockRequest = createMockRequest(constraints)
           const result = await orchestrator.processJob(mockRequest)
           return result.recommendations || []
         }
         ```
    2. Create `src/app/api/agent/route.ts`:
       - Next.js App Router API route
       - POST handler:
         ```typescript
         export async function POST(request: Request) {
           try {
             const body = await request.json()
             
             // Validate request
             const validation = validateJobRequest(body)
             if (!validation.valid) {
               return Response.json(
                 { error: 'Invalid request', details: validation.errors },
                 { status: 400 }
               )
             }
             
             // Process job
             const jobRequest: JobRequest = {
               id: generateJobId(),
               ...body,
               createdAt: new Date()
             }
             
             const result = await orchestrator.processJob(jobRequest)
             
             return Response.json({
               success: true,
               jobId: result.jobId,
               recommendations: result.recommendations,
               reasoningHash: result.reasoningHash,
               totalCost: result.totalCost,
               status: result.status
             })
           } catch (error) {
             console.error('[API] Agent error:', error)
             return Response.json(
               { error: 'Agent processing failed', message: error.message },
               { status: 500 }
             )
           }
         }
         ```
       - Request validation:
         - Required: buyerAddress, gpuCount, durationHours
         - Optional: constraints (maxPrice, regions, gpuType, mode)
         - Validate Ethereum address format
       - Error responses:
         - 400: Invalid request
         - 500: Processing error
         - Include detailed error messages
    3. Create GET handler for health check:
       ```typescript
       export async function GET() {
         return Response.json({
           status: 'ok',
           providers: registry.getAll().length,
           timestamp: new Date().toISOString()
         })
       }
       ```
    4. Test the endpoint:
       - Valid request should return recommendations
       - Invalid request should return 400
       - Error should return 500 with message
    
    This provides the HTTP interface for Phase 2 UI integration.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/lib/agent/index.ts src/app/api/agent/route.ts`
    API route follows Next.js App Router conventions
  </verify>
  <done>
    Public agent API and HTTP endpoint created with validation and error handling
  </done>
</task>

<task type="auto">
  <name>Task 3: Create integration test and documentation</name>
  <files>src/lib/agent/README.md, src/lib/agent/integration.test.ts</files>
  <action>
    Document the agent and create integration verification:
    1. Create `src/lib/agent/README.md`:
       - Overview of agent architecture
       - Pipeline diagram:
         ```
         Job Request → Identity → Filter Providers → Get Quotes → 
         Normalize Prices → Score & Rank → Upload Trace → Recommendations
         ```
       - Usage examples:
         ```typescript
         // Process job with Tracked mode
         const result = await agent.processJob({
           buyerAddress: '0x...',
           gpuCount: 2,
           durationHours: 24,
           constraints: {
             identityMode: IdentityMode.TRACKED,
             teamMemberId: 'user-123'
           }
         })
         
         // Process job with Untracked mode
         const result = await agent.processJob({
           buyerAddress: '0x...',
           gpuCount: 1,
           durationHours: 4,
           constraints: {
             identityMode: IdentityMode.UNTRACKED
           }
         })
         ```
       - Configuration (env vars)
       - Performance expectations (<10 seconds)
    2. Create `src/lib/agent/integration.test.ts`:
       - Simple integration test (not full test framework):
         ```typescript
         // Manual verification script
         async function testAgentIntegration() {
           console.log('Testing agent integration...')
           
           // Test 1: Tracked mode
           const trackedResult = await agent.processJob({
             id: 'test-tracked-1',
             buyerAddress: '0x1234567890123456789012345678901234567890',
             gpuCount: 2,
             durationHours: 10,
             constraints: {
               identityMode: IdentityMode.TRACKED,
               teamMemberId: 'test-user',
               requiredGpuType: GpuType.A100_80GB
             },
             createdAt: new Date()
           })
           
           console.log('✓ Tracked mode result:', trackedResult.jobId)
           console.log('  Provider:', trackedResult.selectedProvider.name)
           console.log('  Hash:', trackedResult.reasoningHash)
           
           // Test 2: Untracked mode
           const untrackedResult = await agent.processJob({
             id: 'test-untracked-1',
             buyerAddress: '0xabcdefabcdefabcdefabcdefabcdefabcdefabcdef',
             gpuCount: 1,
             durationHours: 5,
             constraints: {
               identityMode: IdentityMode.UNTRACKED
             },
             createdAt: new Date()
           })
           
           console.log('✓ Untracked mode result:', untrackedResult.jobId)
           console.log('  Provider:', untrackedResult.selectedProvider.name)
           console.log('  Hash:', untrackedResult.reasoningHash)
           
           console.log('\n✅ All integration tests passed!')
         }
         
         // Run if executed directly
         if (require.main === module) {
           testAgentIntegration().catch(console.error)
         }
         ```
    3. Add to package.json scripts (optional):
       ```json
       "test:agent": "ts-node src/lib/agent/integration.test.ts"
       ```
    
    This verifies the entire agent works end-to-end.
  </action>
  <verify>
    README documents all modules and usage
    Integration test script exists and can be run manually
  </verify>
  <done>
    Agent documented with README and integration test script
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Orchestrator coordinates all 8+ modules
2. Full pipeline executes in <10 seconds
3. HTTP endpoint accepts job requests and returns recommendations
4. Both Tracked and Untracked modes work end-to-end
5. Reasoning hash returned for every job
</verification>

<success_criteria>
- AgentOrchestrator coordinates full pipeline:
  * Identity handling (Tracked/Untracked)
  * Provider filtering
  * Quote fetching from 8 providers
  * Price normalization
  * Ranking and scoring
  * 0G Storage upload
  * Result assembly
- Pipeline completes in <10 seconds (target)
- HTTP API endpoint at /api/agent accepts POST requests
- Request validation returns 400 for invalid input
- Error handling returns 500 with descriptive messages
- Both identity modes work end-to-end
- Reasoning hash included in every response
- Top 3 recommendations returned with tradeoffs
- Integration test verifies full flow
- Documentation explains architecture and usage
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-08-SUMMARY.md`
</output>
