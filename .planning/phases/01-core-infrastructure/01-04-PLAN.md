---
phase: 01-core-infrastructure
plan: 04
type: execute
wave: 2
depends_on: ["01-02", "01-03"]
files_modified:
  - src/lib/pricing/coingecko.ts
  - src/lib/pricing/normalizer.ts
  - src/lib/pricing/gpu-ratios.ts
  - src/lib/pricing/hidden-costs.ts
autonomous: true

must_haves:
  truths:
    - "CoinGecko API returns real-time token prices for FIL, AKT, RNDR"
    - "Prices are cached for 5-10 minutes to avoid rate limits"
    - "GPU normalization converts all prices to A100-equivalent USD/hr"
    - "Hidden costs are included in effective rate calculation"
    - "Output is single comparable USD/GPU-hr for all providers"
  artifacts:
    - path: "src/lib/pricing/coingecko.ts"
      provides: "Token price fetching with caching"
      exports: ["TokenPriceService", "getTokenPrice", "getMultipleTokenPrices"]
    - path: "src/lib/pricing/normalizer.ts"
      provides: "Price normalization pipeline"
      exports: ["PriceNormalizer", "normalizeQuote", "comparePrices"]
    - path: "src/lib/pricing/gpu-ratios.ts"
      provides: "GPU performance benchmark ratios"
      exports: ["GPU_RATIOS", "getA100Equivalent", "normalizeToA100"]
    - path: "src/lib/pricing/hidden-costs.ts"
      provides: "Hidden cost calculations"
      exports: ["calculateHiddenCosts", "HIDDEN_COST_DEFAULTS"]
  key_links:
    - from: "PriceNormalizer"
      to: "TokenPriceService"
      via: "uses token prices for TOKEN pricing model"
    - from: "PriceNormalizer"
      to: "GPU_RATIOS"
      via: "uses ratios for A100-equivalent calculation"
    - from: "normalizeQuote"
      to: "calculateHiddenCosts"
      via: "adds hidden costs to base price"
---

<objective>
Build the pricing normalization pipeline that converts diverse provider pricing (fixed USD, dynamic spot, volatile tokens) into a standardized USD/GPU-hr metric. Implements AGENT-02, AGENT-03, and user decisions on hidden costs and GPU normalization.

Purpose: Enable fair price comparison across all providers regardless of their native pricing model.
Output: Pricing modules for token conversion, GPU normalization, hidden costs, and the unified normalizer.
</objective>

<execution_context>
@/home/julius/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/julius/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-core-infrastructure/01-CONTEXT.md
@.planning/phases/01-core-infrastructure/01-RESEARCH.md
@.planning/phases/01-core-infrastructure/01-02-SUMMARY.md
@.planning/phases/01-core-infrastructure/01-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement CoinGecko token price service with caching</name>
  <files>src/lib/pricing/coingecko.ts</files>
  <action>
    Create token price fetching service with rate limit protection:
    1. Create `src/lib/pricing/coingecko.ts` with:
       - Install dependencies: `npm install axios node-cache` (if not already installed)
       - `TokenPriceCache` class using node-cache:
         * TTL: 10 minutes (600 seconds) per user decision
         * Stores: symbol → { usdPrice, timestamp }
         * checkCache(symbol): TokenPrice | null
         * setCache(symbol, price): void
       - `CoinGeckoConfig`:
         * baseUrl: 'https://api.coingecko.com/api/v3'
         * timeout: 10000ms
         * retryAttempts: 3
         * supportedTokens mapping:
           - filecoin → 'filecoin'
           - akash-network → 'akash'
           - render-token → 'render'
       - `TokenPriceService` class:
         * fetchSinglePrice(tokenId: string): Promise&lt;number&gt;
           - Use /simple/price endpoint
           - Handle 429 rate limit errors with exponential backoff
           - Return cached value if fetch fails (graceful degradation)
         * fetchMultiplePrices(tokenIds: string[]): Promise&lt;Map&lt;string, number&gt;&gt;
           - Batch request for multiple tokens
           - Filter cached values, only fetch missing
         * getPrice(tokenSymbol: string): Promise&lt;TokenPrice&gt;
           - Check cache first
           - Fetch if stale/missing
           - Return { usdPrice, lastUpdated, source }
       - Error handling:
         * `TokenPriceError` with codes: RATE_LIMIT, NETWORK, INVALID_TOKEN
         * Log warnings but don't crash on fetch failures
         * Return stale cache data if available
    2. Add rate limit protection:
       - Track request timestamps
       - Max 25 requests/minute (buffer below 30/min limit)
       - Queue requests if limit approached
    3. Export service instance and helper functions
    
    Per user decision: Use real-time token prices via CoinGecko API.
    Per research: Free tier is 30 calls/min, 10K/month — cache to stay under limits.
    Per research pitfall: Don't query on every normalization — cache for 5-10 min.
  </action>
  <verify>
    Run test fetch: `curl "https://api.coingecko.com/api/v3/simple/price?ids=filecoin,akash-network&vs_currencies=usd"`
    TypeScript compiles without errors
  </verify>
  <done>
    TokenPriceService implemented with 10-min caching, batch fetching, and rate limit protection
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement GPU normalization and hidden costs</name>
  <files>src/lib/pricing/gpu-ratios.ts, src/lib/pricing/hidden-costs.ts</files>
  <action>
    Create GPU normalization and hidden cost calculations:
    1. Create `src/lib/pricing/gpu-ratios.ts`:
       - `GPU_RATIOS` record (A100 80GB = 1.0 baseline):
         ```typescript
         export const GPU_RATIOS: Record&lt;GpuType, number&gt; = {
           A100_80GB: 1.0,
           A100_40GB: 0.9,
           H100: 1.5,
           H200: 2.0,
           RTX4090: 0.6,
           RTX3090: 0.5,
           A10G: 0.4,
           V100: 0.3,
           T4: 0.15,
         }
         ```
       - `getA100Equivalent(gpuType: GpuType): number`:
         * Returns ratio for given GPU type
         * Throws for unknown GPU
       - `normalizeToA100(pricePerHour: number, gpuType: GpuType): number`:
         * Returns price / ratio
         * Example: H100 at $3.00/hr → $3.00/1.5 = $2.00/A100-hr
       - Add JSDoc with ratio source note:
         * "Ratios based on MLPerf inference benchmarks"
         * "Conservative estimates for fair comparison"
    2. Create `src/lib/pricing/hidden-costs.ts`:
       - `HiddenCostFactors` interface per region:
         * bandwidthRate: number ($/GB)
         * storageRate: number ($/GB/month)
         * apiCallRate: number ($/1000 calls)
       - `HIDDEN_COST_DEFAULTS` by region:
         * us-east: { bandwidth: 0.09, storage: 0.023, apiCalls: 0.003 }
         * us-west: { bandwidth: 0.09, storage: 0.023, apiCalls: 0.003 }
         * eu-west: { bandwidth: 0.09, storage: 0.024, apiCalls: 0.003 }
         * (Use AWS-ish defaults as baseline)
       - `calculateHiddenCosts(params)`:
         * Input: { region, durationHours, expectedBandwidthGB, expectedStorageGB }
         * Returns: HiddenCosts interface
         * bandwidthCost = bandwidthGB * bandwidthRate
         * storageCost = storageGB * storageRate * (durationHours/720)
         * apiCost = (durationHours * 10) * apiCallRate // assume 10 calls/hr
         * total = bandwidthCost + storageCost + apiCost
         * All costs amortized to per-hour rate: total / durationHours
       - `estimateUsage(jobRequest: JobRequest)`:
         * Estimates bandwidth/storage based on GPU count and duration
         * Conservative defaults for ML workloads
    3. Per user decision: Include typical usage assumptions in effective rate.
       Document assumptions in code comments.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/lib/pricing/gpu-ratios.ts src/lib/pricing/hidden-costs.ts`
  </verify>
  <done>
    GPU ratios defined (A100=1.0) and hidden cost calculator implemented with regional defaults
  </done>
</task>

<task type="auto">
  <name>Task 3: Create unified price normalizer</name>
  <files>src/lib/pricing/normalizer.ts</files>
  <action>
    Create the main price normalization pipeline:
    1. Create `src/lib/pricing/normalizer.ts` with:
       - `PriceNormalizer` class:
         * Constructor takes TokenPriceService dependency
         * Methods:
           - normalizeQuote(quote: PriceQuote, jobRequest: JobRequest): Promise&lt;NormalizedPrice&gt;
           - normalizeMultipleQuotes(quotes: PriceQuote[], jobRequest: JobRequest): Promise&lt;NormalizedPrice[]&gt;
       - Normalization pipeline (per user decision — output single USD/GPU-hr):
         ```typescript
         async normalizeQuote(quote, jobRequest):
           // 1. Get base price in USD
           let usdPrice: number
           if (quote.currency === 'USD') {
             usdPrice = quote.pricePerHour
           } else if (quote.currency === 'TOKEN' &amp;&amp; quote.tokenSymbol) {
             const tokenPrice = await tokenService.getPrice(quote.tokenSymbol)
             usdPrice = quote.pricePerHour * tokenPrice.usdPrice
           }
           
           // 2. Apply spot discount if applicable
           if (quote.isSpot &amp;&amp; quote.spotDiscountPercent) {
             usdPrice = usdPrice * (1 - quote.spotDiscountPercent / 100)
           }
           
           // 3. Add hidden costs (bandwidth, storage, API)
           const hiddenCosts = calculateHiddenCosts({
             region: quote.region,
             durationHours: jobRequest.durationHours,
             ...estimateUsage(jobRequest)
           })
           const totalPrice = usdPrice + hiddenCosts.total
           
           // 4. Normalize to A100-equivalent
           const a100Ratio = getA100Equivalent(quote.gpuType)
           const effectivePrice = totalPrice / a100Ratio
           
           // 5. Return NormalizedPrice
           return {
             providerId: quote.providerId,
             gpuType: quote.gpuType,
             usdPerGpuHour: totalPrice,
             a100Equivalent: a100Ratio,
             effectiveUsdPerA100Hour: effectivePrice,
             hiddenCosts,
             source: quote.isSpot ? 'SPOT' : quote.currency === 'TOKEN' ? 'TOKEN' : 'FIXED',
             calculatedAt: new Date()
           }
         ```
       - `comparePrices(prices: NormalizedPrice[])`:
         * Sorts by effectiveUsdPerA100Hour (lowest first)
         * Returns ranked array with savings percentages
       - `formatPrice(price: number): string`:
         * Returns "$X.XX/GPU-hr" format per user decision
    2. Add error handling:
       - Catch token fetch failures (use 0 as price, log warning)
       - Handle missing GPU ratios gracefully
       - Return partial results with error flags
    3. Export normalizer instance and utility functions
    
    Per user decision: Output single effective rate displayed to users ($X.XX/GPU-hr).
    This is the core AGENT-02 implementation.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/lib/pricing/normalizer.ts`
    Create simple test to verify normalization logic works end-to-end
  </verify>
  <done>
    PriceNormalizer implemented with full pipeline: token conversion → spot discount → hidden costs → A100 normalization
  </done>
</task>

<task type="auto">
  <name>Task 4: Create pricing barrel export and integration test</name>
  <files>src/lib/pricing/index.ts, src/lib/pricing/README.md</files>
  <action>
    Create unified pricing module exports:
    1. Create `src/lib/pricing/index.ts`:
       - Export all pricing modules:
         ```typescript
         export * from './coingecko'
         export * from './gpu-ratios'
         export * from './hidden-costs'
         export * from './normalizer'
         ```
       - Export singleton instances:
         ```typescript
         import { TokenPriceService } from './coingecko'
         import { PriceNormalizer } from './normalizer'
         export const tokenService = new TokenPriceService()
         export const priceNormalizer = new PriceNormalizer(tokenService)
         ```
    2. Create `src/lib/pricing/README.md`:
       - Brief overview of pricing module
       - Usage example:
         ```typescript
         import { priceNormalizer } from '@/lib/pricing'
         const normalized = await priceNormalizer.normalizeQuote(quote, jobRequest)
         console.log(`Effective rate: ${normalized.effectiveUsdPerA100Hour}/GPU-hr`)
         ```
       - Document the normalization formula
       - Note on CoinGecko rate limits
    3. Verify integration:
       - Check that all imports resolve
       - Ensure no circular dependencies
       - Validate types match between modules
    
    This makes the pricing module easy to import and use.
  </action>
  <verify>
    All exports resolve: `npx tsc --noEmit src/lib/pricing/index.ts`
  </verify>
  <done>
    Pricing module exports unified, documented, and ready for use
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Token prices fetch from CoinGecko with caching
2. GPU normalization converts H100→A100-equivalent correctly
3. Hidden costs added to base price
4. Final output is comparable USD/A100-hr rate
5. All modules compile and export correctly
</verification>

<success_criteria>
- TokenPriceService fetches real-time prices from CoinGecko API
- Prices cached for 10 minutes to respect rate limits (30/min)
- GPU normalization uses A100 80GB as baseline (1.0)
- Hidden costs include bandwidth, storage, and API calls
- Spot discounts applied when applicable
- Token-based pricing converted via real-time exchange rates
- Single effective USD/GPU-hr output for all providers
- Graceful fallback to cached prices on API failures
- All pricing logic documented with assumptions
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-04-SUMMARY.md`
</output>
