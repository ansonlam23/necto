---
phase: 01-core-infrastructure
plan: 07
type: execute
wave: 3
depends_on: ["01-02", "01-06"]
files_modified:
  - src/lib/identity/index.ts
  - src/lib/identity/tracked.ts
  - src/lib/identity/untracked.ts
  - src/lib/identity/hashing.ts
autonomous: true

must_haves:
  truths:
    - "AGENT-06: Tracked mode stores full wallet address, org ID, team member ID"
    - "AGENT-06: Untracked mode hashes wallet/org IDs irreversibly with keccak256"
    - "AGENT-06: Audit trail maintained in both modes without identity linkage in Untracked"
    - "AGENT-06: Mode toggle available in job creation (IdentityMode.TRACKED/UNTRACKED)"
    - "AGENT-06: Hash function uses keccak256 for consistency with blockchain"
  artifacts:
    - path: "src/lib/identity/index.ts"
      provides: "Identity mode management"
      exports: ["IdentityService", "createIdentityRecord"]
    - path: "src/lib/identity/tracked.ts"
      provides: "Tracked mode implementation"
      exports: ["TrackedIdentity", "createTrackedRecord"]
    - path: "src/lib/identity/untracked.ts"
      provides: "Untracked mode implementation"
      exports: ["UntrackedIdentity", "createUntrackedRecord"]
    - path: "src/lib/identity/hashing.ts"
      provides: "Cryptographic hashing utilities"
      exports: ["hashIdentifier", "generateAuditId"]
  key_links:
    - from: "IdentityService"
      to: "createTrackedRecord"
      via: "delegates when mode is TRACKED"
    - from: "IdentityService"
      to: "createUntrackedRecord"
      via: "delegates when mode is UNTRACKED"
    - from: "createUntrackedRecord"
      to: "hashIdentifier"
      via: "hashes wallet and org IDs"
---

<objective>
Implement Tracked/Untracked identity modes for the compute marketplace. Tracked mode stores full identity for team accountability; Untracked mode hashes identifiers for privacy while maintaining audit capability.

Purpose: Support both organizational transparency and individual privacy per user decision.
Output: Identity service with mode-specific handlers, hashing utilities, and audit trail generation.
</objective>

<execution_context>
@/home/julius/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/julius/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-core-infrastructure/01-CONTEXT.md
@.planning/phases/01-core-infrastructure/01-RESEARCH.md
@.planning/phases/01-core-infrastructure/01-02-SUMMARY.md
@.planning/phases/01-core-infrastructure/01-06-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create identity types and hashing utilities</name>
  <files>src/lib/identity/hashing.ts, src/types/identity.ts</files>
  <action>
    Create identity-specific types and cryptographic hashing:
    1. Create/update `src/types/identity.ts`:
       - `IdentityMode` enum: TRACKED, UNTRACKED
       - `IdentityRecord` interface (union type):
         * mode: IdentityMode
         * walletAddress: string (TRACKED) | walletHash: string (UNTRACKED)
         * organizationId?: string (TRACKED) | orgHash?: string (UNTRACKED)
         * teamMemberId?: string (TRACKED only)
         * auditId: string (both modes — unique anonymous ID)
         * createdAt: Date
         * metadata?: Record&lt;string, any&gt;
       - `IdentityContext` interface:
         * walletAddress: string
         * organizationId?: string
         * teamMemberId?: string
         * mode: IdentityMode
    2. Create `src/lib/identity/hashing.ts`:
       - Import { ethers } from 'ethers' (for keccak256)
       - `hashIdentifier(identifier: string, salt?: string): string`:
         * Use ethers.keccak256(ethers.toUtf8Bytes(identifier + salt))
         * Return hex string (0x...)
         * Deterministic: same input → same output
         * Irreversible: cannot derive original from hash
       - `generateAuditId(): string`:
         * Generate UUID or timestamp-based unique ID
         * Used for anonymous audit trail linkage
         * Format: `audit-${timestamp}-${random}`
       - `verifyHash(identifier: string, hash: string, salt?: string): boolean`:
         * Check if hashIdentifier(identifier) === hash
         * For audit verification without revealing identity
       - `SALT_CONSTANT`: Hardcoded salt for consistency:
         * 'synapse-identity-v1'
         * Prevents rainbow table attacks
    3. Add comments:
       - Explain keccak256 choice (Ethereum standard)
       - Document that hashes are irreversible but verifiable
       - Note salt usage for security
    
    Per user decision: Hash wallet address and organization IDs (irreversible but auditable).
    Use keccak256 for blockchain compatibility.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/lib/identity/hashing.ts`
    Test hashing: hashIdentifier('0x123...') should return consistent hex
  </verify>
  <done>
    Hashing utilities with keccak256, salt, and audit ID generation
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement Tracked mode identity handling</name>
  <files>src/lib/identity/tracked.ts</files>
  <action>
    Create Tracked mode implementation for full identity storage:
    1. Create `src/lib/identity/tracked.ts`:
       - `TrackedIdentity` interface:
         * mode: IdentityMode.TRACKED
         * walletAddress: string (full Ethereum address)
         * organizationId?: string
         * teamMemberId?: string
         * auditId: string
         * timestamps: {
             createdAt: Date
             lastActivityAt: Date
           }
         * activityLog: ActivityEntry[]
       - `ActivityEntry` interface:
         * action: 'job_created' | 'job_completed' | 'payment_made'
         * jobId?: string
         * timestamp: Date
         * metadata?: Record&lt;string, any&gt;
       - `createTrackedRecord(context: IdentityContext): TrackedIdentity`:
         * Validate walletAddress format (0x...)
         * Generate auditId
         * Return complete identity record
       - `updateActivity(identity: TrackedIdentity, entry: ActivityEntry): TrackedIdentity`:
         * Add entry to activityLog
         * Update lastActivityAt
         * Return updated identity
       - `getTeamSpending(identity: TrackedIdentity, jobHistory: JobResult[]): TeamSpending`:
         * Aggregate costs by team member if org ID present
         * Calculate per-user totals
         * Return breakdown for dashboard
       - `formatForAudit(identity: TrackedIdentity): object`:
         * Return full identity for audit logs
         * Include all fields except sensitive metadata
    2. Add validation:
       - Check Ethereum address format (0x + 40 hex chars)
       - Ensure organizationId provided if teamMemberId present
       - Validate timestamp formats
    3. Export all functions and types
    
    Per user decision: Tracked mode stores full identity details — wallet address, organization, team member ID, timestamps.
    Enables per-user cost tracking and team accountability.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/lib/identity/tracked.ts`
  </verify>
  <done>
    Tracked mode implemented with full identity storage and activity logging
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement Untracked mode identity handling</name>
  <files>src/lib/identity/untracked.ts</files>
  <action>
    Create Untracked mode with hashed identifiers:
    1. Create `src/lib/identity/untracked.ts`:
       - `UntrackedIdentity` interface:
         * mode: IdentityMode.UNTRACKED
         * walletHash: string (keccak256 of address)
         * orgHash?: string (keccak256 of org ID)
         * auditId: string (unique anonymous identifier)
         * timestamps: {
             createdAt: Date
             lastActivityAt: Date
           }
         * activityLog: AnonymousActivityEntry[]
       - `AnonymousActivityEntry` interface:
         * action: 'job_created' | 'job_completed' | 'payment_made'
         * jobId?: string
         * timestamp: Date
         * metadata: Record&lt;string, any&gt; (no identity info)
       - `createUntrackedRecord(context: IdentityContext): UntrackedIdentity`:
         * Hash walletAddress → walletHash
         * Hash organizationId (if present) → orgHash
         * Generate auditId
         * DO NOT store original identifiers
         * Return anonymous record
       - `updateAnonymousActivity(identity: UntrackedIdentity, entry: AnonymousActivityEntry): UntrackedIdentity`:
         * Add to activityLog
         * Ensure no PII in metadata
         * Update lastActivityAt
       - `formatForAnonymousAudit(identity: UntrackedIdentity): object`:
         * Return record with hashes (not original addresses)
         * Include auditId for correlation
         * Strip any potentially identifying metadata
       - `verifyAnonymousIdentity(walletAddress: string, identity: UntrackedIdentity): boolean`:
         * Check if hash(walletAddress) === identity.walletHash
         * For verification without exposing identity
    2. Privacy safeguards:
       - Validate no raw addresses in activity metadata
       - Check that orgHash present only if original org ID existed
       - Log warning if PII detected in metadata
    3. Export all functions and types
    
    Per user decision: Untracked mode hashes wallet address and organization IDs (irreversible but auditable).
    Keep anonymous audit trail without identity linkage.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/lib/identity/untracked.ts`
    Test: createUntrackedRecord should never store original wallet address
  </verify>
  <done>
    Untracked mode implemented with hashed identifiers and anonymous audit trail
  </done>
</task>

<task type="auto">
  <name>Task 4: Create unified identity service</name>
  <files>src/lib/identity/index.ts</files>
  <action>
    Create unified service that handles both modes:
    1. Create `src/lib/identity/index.ts`:
       - `IdentityService` class:
         * createIdentity(context: IdentityContext): IdentityRecord:
           - Switch on context.mode
           - If TRACKED: return createTrackedRecord(context)
           - If UNTRACKED: return createUntrackedRecord(context)
         * isTracked(record: IdentityRecord): boolean
         * isUntracked(record: IdentityRecord): boolean
         * getAuditId(record: IdentityRecord): string (works for both modes)
         * canTrackSpending(record: IdentityRecord): boolean:
           - Returns true only for TRACKED mode
       - `createJobWithIdentity(jobRequest: JobRequest, identityContext: IdentityContext): JobRequest`:
         * Creates identity record
         * Attaches auditId to jobRequest
         * Sets identityMode on jobRequest.constraints
         * Returns enhanced job request
       - `formatForStorage(record: IdentityRecord): object`:
         * Returns serialized version for 0G Storage
         * Includes mode, hashes (or addresses), auditId, timestamps
         * Excludes activityLog (too large)
       - `verifyIdentityOwnership(walletAddress: string, record: IdentityRecord): boolean`:
         * For TRACKED: direct comparison
         * For UNTRACKED: hash comparison
       - Export singleton: `export const identityService = new IdentityService()`
    2. Re-export all submodules:
       ```typescript
       export * from './hashing'
       export * from './tracked'
       export * from './untracked'
       export { IdentityService, identityService }
       ```
    3. Add TypeScript type guards:
       - `isTrackedIdentity(record): record is TrackedIdentity`
       - `isUntrackedIdentity(record): record is UntrackedIdentity`
    4. Document usage:
       ```typescript
       // Tracked mode
       const tracked = identityService.createIdentity({
         walletAddress: '0x...',
         organizationId: 'acme-corp',
         teamMemberId: 'user-123',
         mode: IdentityMode.TRACKED
       })
       
       // Untracked mode
       const untracked = identityService.createIdentity({
         walletAddress: '0x...',
         mode: IdentityMode.UNTRACKED
       })
       ```
    
    Per requirement AGENT-06: Tracked/Untracked mode toggle with identity stripping.
    Per user decision: Contract architecture is Claude's discretion — use flag parameter (mode field).
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/lib/identity/index.ts`
    All exports resolve correctly
  </verify>
  <done>
    Unified IdentityService with mode toggle, hashing, and audit trail support
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Tracked mode stores full wallet/org/team IDs
2. Untracked mode stores only keccak256 hashes
3. Audit ID generated for both modes
4. Mode toggle switches between implementations
5. Verification works for ownership proof in both modes
</verification>

<success_criteria>
- IdentityMode enum with TRACKED and UNTRACKED values
- Tracked mode stores:
  * Full wallet address (0x...)
  * Organization ID
  * Team member ID
  * Activity timestamps
- Untracked mode stores:
  * keccak256 hash of wallet address
  * keccak256 hash of organization ID (if provided)
  * Anonymous audit ID
  * No original identifiers
- Hash function uses keccak256 with salt
- Same identifier always produces same hash (deterministic)
- IdentityService unified interface handles both modes
- Mode toggle switches implementation transparently
- Audit trail maintained in both modes:
  * Tracked: Links to real identity
  * Untracked: Anonymous but verifiable
- Type guards for TypeScript discrimination
- Activity logging works in both modes (with/without identity)
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-07-SUMMARY.md`
</output>
