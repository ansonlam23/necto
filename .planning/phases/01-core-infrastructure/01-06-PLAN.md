---
phase: 01-core-infrastructure
plan: 06
type: execute
wave: 3
depends_on: ["01-03", "01-04"]
files_modified:
  - src/lib/agent/filter.ts
  - src/lib/agent/scorer.ts
  - src/lib/agent/ranker.ts
  - src/lib/agent/reasoning.ts
autonomous: true

must_haves:
  truths:
    - "AGENT-04: Agent filters providers by constraints (price, region, GPU type, pricing model)"
    - "AGENT-05: Ranking algorithm uses weighted scoring (price 60%, quality 40%)"
    - "AGENT-05: Top 3 providers returned with tradeoff explanations"
    - "AGENT-05: Full reasoning trace captures all decisions and rejections"
    - "AGENT-05: Geographic diversity, latency, reputation factors included in scoring"
  artifacts:
    - path: "src/lib/agent/filter.ts"
      provides: "Constraint-aware filtering"
      exports: ["filterProviders", "ConstraintFilter"]
    - path: "src/lib/agent/scorer.ts"
      provides: "Provider scoring algorithm"
      exports: ["scoreProviders", "calculateScore"]
    - path: "src/lib/agent/ranker.ts"
      provides: "Provider ranking and selection"
      exports: ["rankProviders", "getTopRecommendations"]
    - path: "src/lib/agent/reasoning.ts"
      provides: "Reasoning trace generation"
      exports: ["generateReasoningTrace", "formatTradeoffs"]
  key_links:
    - from: "rankProviders"
      to: "filterProviders"
      via: "first filters, then scores"
    - from: "rankProviders"
      to: "scoreProviders"
      via: "scoring applied to filtered list"
    - from: "rankProviders"
      to: "generateReasoningTrace"
      via: "generates trace from all evaluations"
---

<objective>
Build the provider ranking engine that filters by constraints, scores by weighted factors, and returns top 3 recommendations with tradeoff analysis. Implements AGENT-04 (constraint filtering) and AGENT-05 (dynamic ranking).

Purpose: Intelligent provider selection based on price, quality, geography, and reputation.
Output: Filter, scorer, ranker, and reasoning modules that produce final recommendations.
</objective>

<execution_context>
@/home/julius/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/julius/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-core-infrastructure/01-CONTEXT.md
@.planning/phases/01-core-infrastructure/01-RESEARCH.md
@.planning/phases/01-core-infrastructure/01-03-SUMMARY.md
@.planning/phases/01-core-infrastructure/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement constraint-aware filtering</name>
  <files>src/lib/agent/filter.ts</files>
  <action>
    Create provider filtering based on job constraints:
    1. Create `src/lib/agent/filter.ts`:
       - `FilterResult` interface:
         * provider: ComputeProvider
         * passed: boolean
         * failedConstraints: string[]
         * rejectionReason?: string
       - `ConstraintFilter` class:
         * constructor(no params)
         * filter(providers: ComputeProvider[], constraints: JobConstraints): FilterResult[]:
           - Check each provider against all constraints
           - Return pass/fail with reasons
       - Individual constraint checkers:
         * `checkPriceConstraint(provider, maxPrice)`:
           - Get provider's base price for requested GPU
           - Pass if price <= maxPrice
           - Rejection reason: "Price $X exceeds max $Y"
         * `checkRegionConstraint(provider, preferredRegions)`:
           - Check if provider has instances in any preferred region
           - Pass if intersection exists
           - Rejection reason: "No instances in preferred regions [list]"
         * `checkGpuConstraint(provider, requiredGpuType)`:
           - Check provider capabilities.gpuTypes
           - Pass if required GPU available
           - Rejection reason: "Does not offer {gpuType}"
         * `checkPricingModelConstraint(provider, excludeModels)`:
           - Check if provider.pricingModel in excludeModels
           - Pass if not excluded
           - Rejection reason: "Pricing model {model} excluded by user"
         * `checkCapacityConstraint(provider)`:
           - Per user decision: IGNORE for hackathon
           - Always return true
           - Add comment: "Capacity checking deferred post-hackathon"
       - `filterProviders()` function:
         * Applies all constraints
         * Returns FilterResult array
         * Separates passed and failed for reasoning trace
    2. Add logging:
       - Log number of providers before/after filter
       - Log each rejection with reason
       - Log execution time
    3. Export all functions
    
    Per requirement AGENT-04: Constraint-aware filtering (max price, region, GPU type, pricing model exclusions).
    Per user decision: Ignore provider capacity constraints for hackathon demo.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/lib/agent/filter.ts`
    Create test case with mock providers and constraints
  </verify>
  <done>
    Constraint filter implemented for price, region, GPU type, and pricing model exclusions
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement weighted scoring algorithm</name>
  <files>src/lib/agent/scorer.ts</files>
  <action>
    Create scoring system for provider ranking:
    1. Create `src/lib/agent/scorer.ts`:
       - `ScoreFactors` interface:
         * price: number (0-100)
         * latency: number (0-100)
         * reputation: number (0-100)
         * geography: number (0-100)
       - `ScoredProvider` interface:
         * provider: ComputeProvider
         * normalizedPrice: NormalizedPrice
         * factors: ScoreFactors
         * weightedScore: number
         * breakdown: Record&lt;string, number&gt; (raw contribution per factor)
       - Individual scoring functions (0-100 scale):
         * `scorePrice(normalizedPrice, allPrices): number`:
           - Price score = 100 * (1 - (price / maxPrice))
           - Lower price = higher score
           - Normalize against all providers being scored
         * `scoreLatency(providerRegion, targetRegion): number`:
           - Base score by region distance:
             * Same region: 100
             * Same continent: 80
             * Different continent: 50
           - Adjust for provider's latency reputation
         * `scoreReputation(provider): number`:
           - Use provider.metadata.reputationScore (0-100)
           - Factor in provider.metadata.uptimePercentage
           - New providers get neutral score (50)
         * `scoreGeography(provider, preferredRegions): number`:
           - Count how many preferred regions provider covers
           - Score = 100 * (matchingRegions / totalPreferred)
           - Bonus for geographic diversity
       - `calculateScore(provider, normalizedPrice, weights, context): ScoredProvider`:
         * Calculate all four factor scores
         * Apply weights: weighted = factor * weight
         * Sum to get weightedScore (0-100)
         * Return complete scoring breakdown
       - `scoreProviders()` function:
         * Takes: providers[], normalizedPrices[], weights, jobRequest
         * Returns: ScoredProvider[] sorted by weightedScore (highest first)
         * Calculate min/max prices for normalization
         * Score each provider
         * Sort descending
    2. Use default weights from constants (per user discretion):
       - price: 0.6
       - latency: 0.15
       - reputation: 0.15
       - geography: 0.10
    3. Export all scoring functions
    
    Per user decision: Weighting is Claude's discretion — use 60% price, 40% quality.
    Per user decision: Factors include geographic diversity, historical uptime/reputation, and latency.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/lib/agent/scorer.ts`
  </verify>
  <done>
    Weighted scoring implemented: price (60%), latency (15%), reputation (15%), geography (10%)
  </done>
</task>

<task type="auto">
  <name>Task 3: Implement ranking and recommendation logic</name>
  <files>src/lib/agent/ranker.ts</files>
  <action>
    Create ranking engine that produces top 3 recommendations:
    1. Create `src/lib/agent/ranker.ts`:
       - `RankingResult` interface:
         * recommendations: ProviderRecommendation[]
         * rejected: RejectedProvider[]
         * metadata: { totalProviders, filteredCount, scoredCount, durationMs }
       - `ProviderRecommendation` interface:
         * rank: number (1, 2, or 3)
         * provider: ComputeProvider
         * normalizedPrice: NormalizedPrice
         * totalScore: number
         * scoreBreakdown: Record&lt;string, number&gt;
         * tradeoffs: string[] (human-readable pros/cons)
         * estimatedSavings: string (vs. most expensive option)
       - `RejectedProvider` interface:
         * provider: ComputeProvider
         * rejectionReason: string
         * failedAt: 'filter' | 'scoring'
       - `Ranker` class:
         * constructor(filter, scorer, normalizer)
         * rank(jobRequest: JobRequest): Promise&lt;RankingResult&gt;:
           - Step 1: Get all providers from registry
           - Step 2: Filter by constraints → passed[], rejected[]
           - Step 3: Get quotes from passed providers
           - Step 4: Normalize prices
           - Step 5: Score providers
           - Step 6: Select top 3 with tradeoff analysis
           - Step 7: Return RankingResult
       - `getTopRecommendations(scoredProviders, count=3)`:
         * Slice top N from sorted array
         * Generate tradeoff descriptions for each
       - `generateTradeoffs(recommendation, allRecommendations): string[]`:
         * Compare to other options
         * Generate statements like:
           - "Best price — saves X% vs. option 2"
           - "Lowest latency — same region as request"
           - "Highest reputation — 99.9% uptime"
           - "Tradeoff: Higher price for premium hardware"
    2. Add async handling:
       - Parallel quote fetching from providers
       - Timeout handling (max 5 seconds per provider)
       - Graceful degradation if provider fails
    3. Export Ranker and helper functions
    
    Per user decision: Suggest top 3 providers with tradeoffs highlighted, not just cheapest.
    Per requirement AGENT-05: Dynamic ranking engine by effective cost with quality factors.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/lib/agent/ranker.ts`
  </verify>
  <done>
    Ranker implemented with top-3 recommendations, tradeoff analysis, and parallel quote fetching
  </done>
</task>

<task type="auto">
  <name>Task 4: Implement reasoning trace generation</name>
  <files>src/lib/agent/reasoning.ts</files>
  <action>
    Create full decision tree capture for 0G Storage:
    1. Create `src/lib/agent/reasoning.ts`:
       - `generateReasoningTrace(params): ReasoningTrace`:
         * Input: jobRequest, filterResults, scoredProviders, weights, duration
         * Build complete trace:
           ```typescript
           {
             timestamp: new Date().toISOString(),
             jobId: jobRequest.id,
             providerCount: totalProviders,
             query: {
               gpuType: jobRequest.constraints.requiredGpuType,
               region: jobRequest.constraints.preferredRegions,
               duration: jobRequest.durationHours,
               identityMode: jobRequest.constraints.identityMode
             },
             weights: usedWeights,
             candidates: passedFilters.slice(0, 5).map(p =&gt; ({
               providerId: p.provider.id,
               providerName: p.provider.name,
               rawPrice: p.normalizedPrice.usdPerGpuHour,
               normalizedPrice: p.normalizedPrice.effectiveUsdPerA100Hour,
               scores: p.factors,
               rejectionReason: undefined
             })),
             rejected: rejectedProviders.slice(0, 5).map(r =&gt; ({
               providerId: r.provider.id,
               providerName: r.provider.name,
               rawPrice: null,
               normalizedPrice: null,
               scores: {},
               rejectionReason: r.rejectionReason
             })),
             finalRanking: top3.map((r, i) =&gt; ({
               providerId: r.provider.id,
               providerName: r.provider.name,
               totalScore: r.totalScore,
               normalizedPrice: r.normalizedPrice,
               rank: i + 1
             })),
             metadata: {
               agentVersion: '1.0.0',
               calculationTimeMs: duration,
               filteredCount: passedFilters.length,
               scoredCount: scoredProviders.length
             }
           }
           ```
       - `formatTradeoffs(recommendations): string`:
         * Human-readable summary of recommendations
         * Markdown format for display
       - `summarizeRejection(reason: string): string`:
         * Convert technical rejection to user-friendly message
       - Validation:
         * Ensure all required fields present
         * Validate provider IDs
         * Check timestamp format
    2. Per user decision requirements:
       - Include every provider checked
       - Include rejected reasons
       - Include final ranking
       - Top 5 providers considered (not just final ranking)
       - Format: JSON with scores, weights, calculations
       - Metadata: timestamp, job ID, provider count
    3. Export trace generation functions
    
    Per requirement 0G-01: Full decision tree captured — every provider checked, rejected reasons, final ranking.
    Per user decision: Reasoning trace scope is top 5 providers considered.
  </action>
  <verify>
    TypeScript compiles: `npx tsc --noEmit src/lib/agent/reasoning.ts`
    ReasoningTrace output validates against type definition
  </verify>
  <done>
    Reasoning trace generation captures full decision tree with top 5 candidates, rejections, and metadata
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. Filter removes providers that don't meet constraints
2. Scoring produces 0-100 scores for each factor
3. Ranker returns top 3 with tradeoff descriptions
4. Reasoning trace includes all 5+ required fields
5. All modules integrate smoothly
</verification>

<success_criteria>
- Constraint filtering by maxPrice, regions, GPU type, pricing models
- Capacity constraints ignored per user decision
- Weighted scoring: price (60%), latency (15%), reputation (15%), geography (10%)
- Score normalization (0-100 scale) for fair comparison
- Top 3 providers returned with ranking
- Tradeoff descriptions explain price vs quality decisions
- Reasoning trace includes:
  * Every provider checked (top 5 candidates)
  * Rejection reasons for filtered providers
  * Final ranking with scores
  * Weights used in calculation
  * Metadata (timestamp, job ID, count)
- Trace format is JSON with technical details
- Execution time tracked for performance monitoring
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-06-SUMMARY.md`
</output>
