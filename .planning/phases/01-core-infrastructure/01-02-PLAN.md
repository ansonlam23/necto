---
phase: 01-core-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/types/agent.ts
  - src/types/provider.ts
  - src/types/job.ts
  - src/types/pricing.ts
  - src/lib/constants.ts
autonomous: true

must_haves:
  truths:
    - "AGENT-01: TypeScript types enable provider adapter implementations"
    - "AGENT-02: Pricing types support USD normalization and hidden costs"
    - "AGENT-03: Token price types for CoinGecko integration"
    - "AGENT-04: Job constraints types for filtering providers"
    - "AGENT-05: Ranking and scoring types for provider evaluation"
    - "AGENT-06: IdentityMode enum with TRACKED/UNTRACKED variants"
    - "0G-01: ReasoningTrace type for upload to 0G Storage"
    - "All types support A100-equivalent GPU normalization"
  artifacts:
    - path: "src/types/provider.ts"
      provides: "Provider and GPU type definitions"
      exports: ["ComputeProvider", "GpuType", "PricingModel", "ProviderCapabilities"]
    - path: "src/types/job.ts"
      provides: "Job request and result types"
      exports: ["JobRequest", "JobResult", "JobStatus", "IdentityMode"]
    - path: "src/types/pricing.ts"
      provides: "Pricing normalization types"
      exports: ["NormalizedPrice", "TokenPrice", "PriceQuote", "HiddenCosts"]
    - path: "src/types/agent.ts"
      provides: "Agent reasoning and ranking types"
      exports: ["ReasoningTrace", "ProviderScore", "RankingWeights", "ProviderEvaluation"]
    - path: "src/lib/constants.ts"
      provides: "Application constants and configuration"
      exports: ["GPU_RATIOS", "SUPPORTED_PROVIDERS", "DEFAULT_WEIGHTS", "HIDDEN_COSTS"]
  key_links:
    - from: "JobRequest"
      to: "ComputeProvider"
      via: "job constraints filter provider list"
    - from: "NormalizedPrice"
      to: "ComputeProvider"
      via: "price normalization uses provider's raw pricing"
    - from: "ReasoningTrace"
      to: "ProviderScore"
      via: "trace contains scored provider evaluations"
---

<objective>
Create the core TypeScript type definitions and interfaces for the agent system. These types define the domain model for providers, jobs, pricing, and reasoning traces that all other modules depend on.

Purpose: Establish shared type contracts between agent modules, smart contracts, and UI components.
Output: Complete type system in src/types/ and constants in src/lib/constants.ts.
</objective>

<execution_context>
@/home/julius/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/julius/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/REQUIREMENTS.md
@.planning/phases/01-core-infrastructure/01-CONTEXT.md
@.planning/phases/01-core-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create provider and GPU type definitions</name>
  <files>src/types/provider.ts</files>
  <action>
    Create comprehensive provider type definitions:
    1. Create `src/types/provider.ts` with:
       - `GpuType` enum: A100_80GB, A100_40GB, H100, H200, RTX4090, RTX3090, A10G, V100, T4 (and any others needed)
       - `PricingModel` enum: FIXED, SPOT, TOKEN
       - `ProviderCapabilities` interface: gpuTypes[], regions[], maxDurationHours, supportsSpot
       - `ComputeProvider` interface:
         * id: string (unique identifier)
         * name: string (display name)
         * type: 'akash' | 'lambda' | 'filecoin' | 'ionet' | 'synapse'
         * pricingModel: PricingModel
         * capabilities: ProviderCapabilities
         * metadata: { description, website, reputationScore, uptimePercentage }
         * isActive: boolean
         * listedAt: Date
       - `ProviderInstance` interface (specific offering):
         * providerId: string
         * gpuType: GpuType
         * region: string
         * pricePerHour: number (raw price in native currency)
         * tokenSymbol?: string (for TOKEN pricing model)
         * spotDiscount?: number (percentage for SPOT model)
    2. Add JSDoc comments explaining each field
    3. Export all types from a barrel file if needed
    
    Align with user decision: GPU normalization to A100-equivalent using performance ratios.
    Include geographic diversity field (region codes like 'us-east', 'eu-west', 'ap-south').
  </action>
  <verify>
    TypeScript compiles without errors: `npx tsc --noEmit src/types/provider.ts`
  </verify>
  <done>
    Provider types defined with GPU enum, pricing models, capabilities, and instance types
  </done>
</task>

<task type="auto">
  <name>Task 2: Create job and identity type definitions</name>
  <files>src/types/job.ts</files>
  <action>
    Create job lifecycle and identity types:
    1. Create `src/types/job.ts` with:
       - `IdentityMode` enum: TRACKED, UNTRACKED (implements AGENT-06)
       - `JobStatus` enum: PENDING, CONFIRMED, RUNNING, COMPLETED, FAILED, CANCELLED
       - `JobConstraints` interface:
         * maxPricePerHour?: number
         * preferredRegions?: string[]
         * requiredGpuType?: GpuType
         * minGpuCount?: number
         * maxDurationHours?: number
         * excludePricingModels?: PricingModel[]
         * identityMode: IdentityMode
       - `JobRequest` interface:
         * id: string (UUID or similar)
         * buyerAddress: string
         * constraints: JobConstraints
         * durationHours: number
         * gpuCount: number
         * createdAt: Date
         * teamMemberId?: string (for TRACKED mode only)
       - `JobResult` interface:
         * jobId: string
         * selectedProvider: ComputeProvider
         * normalizedPrice: NormalizedPrice (reference from pricing.ts)
         * totalCost: number
         * status: JobStatus
         * reasoningHash: string (0G content hash)
         * createdAt: Date
         * completedAt?: Date
       - `IdentityRecord` interface (for TRACKED mode):
         * walletAddress: string
         * organizationId?: string
         * teamMemberId?: string
         * timestamps: { createdAt, updatedAt }
       - `AnonymizedIdentity` interface (for UNTRACKED mode):
         * walletHash: string (keccak256 hash)
         * orgHash?: string (keccak256 hash)
         * auditId: string (unique anonymous identifier)
    2. Add utility types:
       - `CreateJobPayload` (input for creating jobs)
       - `JobFilters` (for querying jobs)
    3. Include JSDoc comments
    
    Per user decision: Tracked mode stores full identity; Untracked mode hashes wallet/org IDs.
  </action>
  <verify>
    TypeScript compiles without errors: `npx tsc --noEmit src/types/job.ts`
  </verify>
  <done>
    Job types defined with identity modes, constraints, and lifecycle states
  </done>
</task>

<task type="auto">
  <name>Task 3: Create pricing and agent reasoning types</name>
  <files>src/types/pricing.ts, src/types/agent.ts</files>
  <action>
    Create pricing normalization and agent reasoning types:
    1. Create `src/types/pricing.ts` with:
       - `TokenPrice` interface:
         * symbol: string
         * usdPrice: number
         * lastUpdated: Date
         * source: 'coingecko' | 'cached' | 'manual'
       - `HiddenCosts` interface (per user decision):
         * bandwidthUsdPerHour: number
         * storageUsdPerHour: number
         * apiCallsUsdPerHour: number
         * total: number
       - `PriceQuote` interface (raw from provider):
         * providerId: string
         * gpuType: GpuType
         * pricePerHour: number
         * currency: 'USD' | 'TOKEN'
         * tokenSymbol?: string
         * region: string
         * isSpot: boolean
         * spotDiscountPercent?: number
       - `NormalizedPrice` interface (implements AGENT-02):
         * providerId: string
         * gpuType: GpuType
         * usdPerGpuHour: number
         * a100Equivalent: number (performance ratio)
         * effectiveUsdPerA100Hour: number
         * hiddenCosts: HiddenCosts
         * source: PricingModel
         * calculatedAt: Date
    2. Create `src/types/agent.ts` with:
       - `RankingWeights` interface (implements AGENT-05):
         * price: number (0-1)
         * latency: number (0-1)
         * reputation: number (0-1)
         * geography: number (0-1)
       - `ProviderEvaluation` interface:
         * provider: ComputeProvider
         * instance: ProviderInstance
         * normalizedPrice: NormalizedPrice
         * scores: {
             price: number (0-100)
             latency: number (0-100)
             reputation: number (0-100)
             geography: number (0-100)
           }
         * rejectionReason?: string
       - `ProviderScore` interface (final ranking):
         * providerId: string
         * providerName: string
         * totalScore: number
         * normalizedPrice: NormalizedPrice
         * tradeoffs: string[]
       - `ReasoningTrace` interface (implements 0G-01 requirements):
         * timestamp: string (ISO 8601)
         * jobId: string
         * providerCount: number
         * query: JobConstraints
         * weights: RankingWeights
         * candidates: ProviderEvaluation[] (top 5 per user decision)
         * rejected: ProviderEvaluation[] (with reasons)
         * finalRanking: ProviderScore[] (top 3 per user decision)
         * metadata: { agentVersion, calculationTimeMs }
    3. Add helper types:
       - `FilterResult` (pass/fail with reason)
       - `AggregationResult` (multiple provider quotes)
    
    Per user decision: Reasoning trace includes full decision tree with top 5 providers considered.
    Format is JSON with scores, weights, and calculations.
  </action>
  <verify>
    TypeScript compiles without errors for both files
  </verify>
  <done>
    Pricing and agent types defined with normalization, weights, and reasoning trace structures
  </done>
</task>

<task type="auto">
  <name>Task 4: Create constants and configuration</name>
  <files>src/lib/constants.ts</files>
  <action>
    Create application constants file:
    1. Create `src/lib/constants.ts` with:
       - `GPU_RATIOS` object (A100 80GB as baseline = 1.0):
         * A100_80GB: 1.0
         * A100_40GB: 0.9
         * H100: 1.5
         * H200: 2.0
         * RTX4090: 0.6
         * RTX3090: 0.5
         * A10G: 0.4
         * V100: 0.3
         * T4: 0.15
         (Use conservative estimates; document assumptions in comments)
       - `SUPPORTED_PROVIDERS` array:
         * Akash Network
         * Lambda Labs
         * Filecoin (via FVM)
         * io.net
         * 3-4 mock "Synapse-listed" providers for demo
       - `DEFAULT_WEIGHTS` (RankingWeights):
         * price: 0.6 (per user discretion - price priority)
         * latency: 0.15
         * reputation: 0.15
         * geography: 0.1
       - `HIDDEN_COSTS` defaults (per user decision):
         * bandwidthUsdPerHour: 0.05
         * storageUsdPerHour: 0.02
         * apiCallsUsdPerHour: 0.01
       - `COINMARKETCAP_CONFIG`:
         * apiEndpoint: 'https://api.coingecko.com/api/v3'
         * cacheMinutes: 10
         * supportedTokens: ['filecoin', 'akash-network', 'render-token']
       - `ZERO_G_CONFIG`:
         * chainId: 16602
         * rpcUrl: 'https://evmrpc-testnet.0g.ai'
         * indexerUrl: 'https://indexer-storage-testnet-turbo.0g.ai'
         * maxRetries: 3
       - `PROVIDER_MOCK_DATA` array with realistic pricing for 6-8 providers:
         * Include mix of FIXED, SPOT, TOKEN pricing models
         * Realistic GPU types and prices
         * Multiple regions
    2. Add region codes constant: REGIONS = ['us-east', 'us-west', 'eu-west', 'eu-central', 'ap-south', 'ap-northeast']
    3. Add job constraints defaults
    
    All values should be typed and exported.
    Document the source of ratios and assumptions in comments.
  </action>
  <verify>
    TypeScript compiles and constants are importable: `npx tsc --noEmit src/lib/constants.ts`
  </verify>
  <done>
    Constants file created with GPU ratios, provider configs, default weights, and mock data
  </done>
</task>

</tasks>

<verification>
After all tasks complete:
1. All type files compile: `npx tsc --noEmit src/types/*.ts`
2. Constants file is importable and typed
3. Types align with smart contract structs (where applicable)
4. No circular dependencies between type files
</verification>

<success_criteria>
- Complete TypeScript types for Provider, Job, Pricing, and Agent domains
- GPU performance ratios defined (A100 = 1.0 baseline)
- IdentityMode enum supports TRACKED and UNTRACKED
- ReasoningTrace type includes full decision tree structure
- RankingWeights interface with price/latency/reputation/geography
- Constants for supported providers, default weights, hidden costs
- Realistic mock data for 6-8 providers with varied pricing models
- All types properly exported and documented
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-infrastructure/01-02-SUMMARY.md`
</output>
