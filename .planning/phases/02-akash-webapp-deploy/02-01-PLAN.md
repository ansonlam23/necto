---
phase: 02-akash-webapp-deploy
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - offchain/src/lib/akash/console-api.ts
  - offchain/src/lib/akash/sdl-generator.ts
  - offchain/src/lib/contracts/testnet-usdc-escrow.ts
  - offchain/src/lib/contracts/testnet-usdc-token.ts
  - offchain/src/types/akash.ts
autonomous: false
user_setup:
  - service: Akash Console API
    why: "Real Akash deployments via Console API using actual provider network"
    env_vars:
      - name: AKASH_CONSOLE_API_KEY
        source: "Akash Console (https://console.akash.network)"
      - name: AKASH_CONSOLE_API_URL
        value: "https://console-api.akash.network"
  - service: ADI Testnet USDC Contract
    why: "Fake/test USDC on ADI Testnet (chain 99999) - NOT real money, same chain as ComputeRouter"
    env_vars:
      - name: ADI_TESTNET_USDC_ADDRESS
        source: "Deploy TestnetUSDC.sol on ADI Testnet using Hardhat/Ignition"
      - name: ADI_TESTNET_ESCROW_ADDRESS
        source: "Deploy AkashEscrow.sol on ADI Testnet after USDC"
      - name: ADI_ADI_TESTNET_RPC_URL
        value: "https://rpc.ab.testnet.adifoundation.ai/"
      - name: ADI_TESTNET_CHAIN_ID
        value: "99999"
must_haves:
  truths:
    - "Console API client uses real Akash provider network for deployments"
    - "SDL generator converts natural language job requirements to valid Akash SDL"
    - "SDL templates fetched from awesome-akash repo (290+ templates) + 6 hardcoded core templates"
    - "Testnet USDC is FAKE money on ADI Testnet - used only for testing/demo purposes"
    - "Escrow contract holds testnet USDC on ADI Testnet (chain 99999), releases to Necto on deployment"
    - "All contract interactions on ADI Testnet only - same chain as ComputeRouter"
    - "TypeScript strict mode with full type definitions for all Akash types"
  artifacts:
    - path: "offchain/src/lib/akash/console-api.ts"
      provides: "Akash Console API client for deployment management"
      exports: ["AkashConsoleClient", "createDeployment", "getDeploymentStatus", "closeDeployment"]
    - path: "offchain/src/lib/akash/sdl-generator.ts"
      provides: "SDL generator from natural language job requirements"
      exports: ["generateSDL", "validateSDL", "SdlTemplate"]
    - path: "offchain/src/lib/contracts/testnet-usdc-escrow.ts"
      provides: "Escrow contract integration for testnet USDC"
      exports: ["ESCROW_ABI", "ESCROW_ADDRESS", "depositEscrow", "releaseEscrow", "refundEscrow"]
    - path: "offchain/src/lib/contracts/testnet-usdc-token.ts"
      provides: "Testnet USDC token contract interface"
      exports: ["USDC_ABI", "USDC_ADDRESS", "approveUSDC", "getUSDCBalance"]
    - path: "offchain/src/types/akash.ts"
      provides: "TypeScript types for Akash integration"
      exports: ["AkashDeployment", "SdlSpec", "ProviderBid", "LeaseStatus"]
  key_links:
    - from: "offchain/src/lib/akash/console-api.ts"
      to: "offchain/src/lib/akash/sdl-generator.ts"
      via: "Console API receives generated SDL for deployment"
    - from: "offchain/src/lib/contracts/testnet-usdc-escrow.ts"
      to: "offchain/src/lib/akash/console-api.ts"
      via: "Escrow release triggers deployment creation"
---

<objective>
Build the foundational infrastructure for Akash Network integration including Console API client, SDL generator, and testnet USDC escrow system. Enable real Akash deployments with fake/test token payments.

Purpose: Establish the core infrastructure layer that connects Necto to Akash Network via Console API while using testnet USDC (not real money) for payments through an on-chain escrow system.

Output: Complete infrastructure with Console API client, SDL generation, and testnet USDC escrow contracts. All code TypeScript strict mode compliant.
</objective>

<execution_context>
@/home/julius/.claude/get-shit-done/workflows/execute-plan.md
@/home/julius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-akash-webapp-deploy/02-CONTEXT.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Akash Console API client</name>
  <files>offchain/src/lib/akash/console-api.ts, offchain/src/types/akash.ts</files>
  <action>
    **Create `offchain/src/types/akash.ts` with TypeScript interfaces:**

    ```typescript
    /**
     * Akash Network Type Definitions
     * Types for Console API integration and deployments
     */

    export interface AkashDeployment {
      id: string;
      owner: string;
      dseq: string;
      status: DeploymentStatus;
      createdAt: string;
      expiresAt?: string;
      sdl: SdlSpec;
      leases: Lease[];
    }

    export type DeploymentStatus = 
      | 'pending'
      | 'active'
      | 'closed'
      | 'error';

    export interface SdlSpec {
      version: string;
      services: Record<string, Service>;
      profiles: {
        compute: Record<string, ComputeProfile>;
        placement: Record<string, PlacementProfile>;
      };
      deployment: Record<string, DeploymentConfig>;
    }

    export interface Service {
      image: string;
      expose: Expose[];
      env?: string[];
      command?: string[];
      args?: string[];
    }

    export interface Expose {
      port: number;
      as: number;
      to?: { global: boolean }[];
      accept?: string[];
    }

    export interface ComputeProfile {
      resources: Resources;
    }

    export interface Resources {
      cpu: { units: string };
      memory: { size: string };
      storage: { size: string }[];
      gpu?: { units: string; attributes?: { key: string; value: string }[] };
    }

    export interface PlacementProfile {
      attributes?: { key: string; value: string }[];
      signedBy?: { allOf?: string[]; anyOf?: string[] };
      pricing: Record<string, { denom: string; amount: string }>;
    }

    export interface DeploymentConfig {
      profile: string;
      count: number;
    }

    export interface ProviderBid {
      id: string;
      provider: string;
      price: { denom: string; amount: string };
      resources: Resources;
      createdAt: string;
    }

    export interface Lease {
      id: string;
      provider: string;
      status: LeaseStatus;
      price: { denom: string; amount: string };
      createdAt: string;
    }

    export type LeaseStatus = 'active' | 'closed';

    export interface CreateDeploymentRequest {
      sdl: SdlSpec;
      deposit?: { denom: string; amount: string };
    }

    export interface ConsoleApiConfig {
      apiKey: string;
      baseUrl: string;
    }
    ```

    **Create `offchain/src/lib/akash/console-api.ts`:**

    ```typescript
    /**
     * Akash Console API Client
     * Manages real Akash deployments via Console API
     * Uses https://console-api.akash.network
     */

    import {
      AkashDeployment,
      DeploymentStatus,
      SdlSpec,
      ProviderBid,
      Lease,
      CreateDeploymentRequest,
      ConsoleApiConfig
    } from '@/types/akash';

    const DEFAULT_BASE_URL = 'https://console-api.akash.network';

    export class AkashConsoleClient {
      private apiKey: string;
      private baseUrl: string;

      constructor(config: ConsoleApiConfig) {
        this.apiKey = config.apiKey;
        this.baseUrl = config.baseUrl || DEFAULT_BASE_URL;
      }

      private async fetch<T>(endpoint: string, options?: RequestInit): Promise<T> {
        const url = `${this.baseUrl}${endpoint}`;
        const response = await fetch(url, {
          ...options,
          headers: {
            'Authorization': `Bearer ${this.apiKey}`,
            'Content-Type': 'application/json',
            ...options?.headers
          }
        });

        if (!response.ok) {
          const error = await response.text();
          throw new Error(`Console API error: ${response.status} - ${error}`);
        }

        return response.json();
      }

      /**
       * Create a new deployment with SDL
       */
      async createDeployment(request: CreateDeploymentRequest): Promise<AkashDeployment> {
        return this.fetch<AkashDeployment>('/v1/deployments', {
          method: 'POST',
          body: JSON.stringify(request)
        });
      }

      /**
       * Get deployment by ID
       */
      async getDeployment(deploymentId: string): Promise<AkashDeployment> {
        return this.fetch<AkashDeployment>(`/v1/deployments/${deploymentId}`);
      }

      /**
       * List all deployments for owner
       */
      async listDeployments(owner: string): Promise<AkashDeployment[]> {
        return this.fetch<AkashDeployment[]>(`/v1/deployments?owner=${owner}`);
      }

      /**
       * Close a deployment
       */
      async closeDeployment(deploymentId: string): Promise<void> {
        await this.fetch<void>(`/v1/deployments/${deploymentId}/close`, {
          method: 'POST'
        });
      }

      /**
       * Get bids for a deployment
       */
      async getBids(deploymentId: string): Promise<ProviderBid[]> {
        return this.fetch<ProviderBid[]>(`/v1/deployments/${deploymentId}/bids`);
      }

      /**
       * Accept a bid to create a lease
       */
      async acceptBid(deploymentId: string, bidId: string): Promise<Lease> {
        return this.fetch<Lease>(`/v1/deployments/${deploymentId}/bids/${bidId}/accept`, {
          method: 'POST'
        });
      }

      /**
       * Get deployment logs
       */
      async getLogs(deploymentId: string, follow?: boolean): Promise<ReadableStream> {
        const url = `${this.baseUrl}/v1/deployments/${deploymentId}/logs${follow ? '?follow=true' : ''}`;
        const response = await fetch(url, {
          headers: { 'Authorization': `Bearer ${this.apiKey}` }
        });
        
        if (!response.ok || !response.body) {
          throw new Error('Failed to fetch logs');
        }

        return response.body;
      }

      /**
       * Get deployment status with polling
       */
      async pollDeploymentStatus(
        deploymentId: string,
        targetStatus: DeploymentStatus,
        timeoutMs: number = 300000,
        intervalMs: number = 5000
      ): Promise<AkashDeployment> {
        const startTime = Date.now();
        
        while (Date.now() - startTime < timeoutMs) {
          const deployment = await this.getDeployment(deploymentId);
          
          if (deployment.status === targetStatus) {
            return deployment;
          }
          
          if (deployment.status === 'error') {
            throw new Error('Deployment failed');
          }
          
          await new Promise(resolve => setTimeout(resolve, intervalMs));
        }
        
        throw new Error('Deployment polling timeout');
      }
    }

    // Singleton instance
    let consoleClient: AkashConsoleClient | null = null;

    export function getConsoleClient(): AkashConsoleClient {
      if (!consoleClient) {
        const apiKey = process.env.AKASH_CONSOLE_API_KEY;
        const baseUrl = process.env.AKASH_CONSOLE_API_URL || DEFAULT_BASE_URL;
        
        if (!apiKey) {
          throw new Error('AKASH_CONSOLE_API_KEY not configured');
        }
        
        consoleClient = new AkashConsoleClient({ apiKey, baseUrl });
      }
      
      return consoleClient;
    }

    export function resetConsoleClient(): void {
      consoleClient = null;
    }

    /**
     * Convenience functions using singleton
     */
    export async function createDeployment(sdl: SdlSpec): Promise<AkashDeployment> {
      const client = getConsoleClient();
      return client.createDeployment({ sdl });
    }

    export async function getDeploymentStatus(deploymentId: string): Promise<AkashDeployment> {
      const client = getConsoleClient();
      return client.getDeployment(deploymentId);
    }

    export async function closeDeployment(deploymentId: string): Promise<void> {
      const client = getConsoleClient();
      return client.closeDeployment(deploymentId);
    }

    export async function getDeploymentBids(deploymentId: string): Promise<ProviderBid[]> {
      const client = getConsoleClient();
      return client.getBids(deploymentId);
    }

    export async function acceptProviderBid(deploymentId: string, bidId: string): Promise<Lease> {
      const client = getConsoleClient();
      return client.acceptBid(deploymentId, bidId);
    }
    ```
  </action>
  <verify>
    Run `npx eslint offchain/src/lib/akash/console-api.ts` - no lint errors.
    Run `npx eslint offchain/src/types/akash.ts` - no lint errors.
    Verify TypeScript compilation passes.
  </verify>
  <done>
    Akash Console API client created with full type definitions.
    Singleton pattern with convenience functions.
    Error handling and polling support included.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement SDL generator for job requirements</name>
  <files>offchain/src/lib/akash/sdl-generator.ts</files>
  <action>
    **Create `offchain/src/lib/akash/sdl-generator.ts`:**

    ```typescript
    /**
     * SDL Generator Module
     * Converts natural language job requirements to Akash SDL
     * Supports templates and custom configurations
     */

    import { SdlSpec, Service, Resources, ComputeProfile, PlacementProfile } from '@/types/akash';

    export interface JobRequirements {
      name: string;
      image: string;
      command?: string[];
      args?: string[];
      env?: Record<string, string>;
      cpu?: number;
      memory?: string;
      storage?: string;
      gpu?: {
        units: number;
        model?: string;
      };
      port?: number;
      expose?: boolean;
      count?: number;
      region?: string;
    }

    export interface SdlTemplate {
      id: string;
      name: string;
      description: string;
      category: 'ai' | 'compute' | 'storage' | 'web';
      requirements: JobRequirements;
      tags: string[];
    }

    const TEMPLATES: SdlTemplate[] = [
      {
        id: 'pytorch-gpu',
        name: 'PyTorch GPU Training',
        description: 'NVIDIA GPU-optimized PyTorch environment for ML training',
        category: 'ai',
        requirements: {
          name: 'pytorch',
          image: 'pytorch/pytorch:latest',
          cpu: 4,
          memory: '16Gi',
          storage: '100Gi',
          gpu: { units: 1, model: 'nvidia' },
          port: 8888,
          expose: true
        },
        tags: ['pytorch', 'ml', 'gpu', 'jupyter']
      },
      {
        id: 'jupyter-notebook',
        name: 'Jupyter Notebook',
        description: 'Interactive Python environment with Jupyter',
        category: 'ai',
        requirements: {
          name: 'jupyter',
          image: 'jupyter/scipy-notebook:latest',
          cpu: 2,
          memory: '8Gi',
          storage: '50Gi',
          port: 8888,
          expose: true
        },
        tags: ['jupyter', 'python', 'notebook', 'data-science']
      },
      {
        id: 'stable-diffusion',
        name: 'Stable Diffusion',
        description: 'AI image generation with Stable Diffusion WebUI',
        category: 'ai',
        requirements: {
          name: 'sd-webui',
          image: 'neonstable/stable-diffusion-webui:latest',
          cpu: 4,
          memory: '16Gi',
          storage: '100Gi',
          gpu: { units: 1, model: 'nvidia' },
          port: 7860,
          expose: true
        },
        tags: ['stable-diffusion', 'ai', 'image-generation', 'gpu']
      },
      {
        id: 'ollama',
        name: 'Ollama LLM',
        description: 'Run local LLMs with Ollama',
        category: 'ai',
        requirements: {
          name: 'ollama',
          image: 'ollama/ollama:latest',
          cpu: 8,
          memory: '32Gi',
          storage: '200Gi',
          gpu: { units: 1, model: 'nvidia' },
          port: 11434,
          expose: true
        },
        tags: ['ollama', 'llm', 'ai', 'gpu']
      },
      {
        id: 'nginx-web',
        name: 'NGINX Web Server',
        description: 'Simple NGINX web server',
        category: 'web',
        requirements: {
          name: 'web',
          image: 'nginx:alpine',
          cpu: 0.5,
          memory: '512Mi',
          storage: '1Gi',
          port: 80,
          expose: true
        },
        tags: ['nginx', 'web', 'static']
      },
      {
        id: 'postgres-db',
        name: 'PostgreSQL Database',
        description: 'Production-ready PostgreSQL instance',
        category: 'storage',
        requirements: {
          name: 'postgres',
          image: 'postgres:15-alpine',
          env: { POSTGRES_PASSWORD: 'changeme' },
          cpu: 1,
          memory: '2Gi',
          storage: '50Gi',
          port: 5432,
          expose: false
        },
        tags: ['postgres', 'database', 'sql']
      }
    ];

    /**
     * Generate SDL from job requirements
     */
    export function generateSDL(requirements: JobRequirements): SdlSpec {
      const service: Service = {
        image: requirements.image,
        expose: []
      };

      if (requirements.command) {
        service.command = requirements.command;
      }

      if (requirements.args) {
        service.args = requirements.args;
      }

      if (requirements.env) {
        service.env = Object.entries(requirements.env).map(
          ([key, value]) => `${key}=${value}`
        );
      }

      if (requirements.port) {
        service.expose.push({
          port: requirements.port,
          as: requirements.port,
          ...(requirements.expose && { to: [{ global: true }] })
        });
      }

      const resources: Resources = {
        cpu: { units: String(requirements.cpu || 1) },
        memory: { size: requirements.memory || '1Gi' },
        storage: [{ size: requirements.storage || '10Gi' }]
      };

      if (requirements.gpu && requirements.gpu.units > 0) {
        resources.gpu = {
          units: String(requirements.gpu.units),
          attributes: requirements.gpu.model
            ? [{ key: 'vendor', value: 'nvidia' }]
            : undefined
        };
      }

      const computeProfile: ComputeProfile = { resources };

      const placementProfile: PlacementProfile = {
        pricing: {
          [requirements.name]: { denom: 'uakt', amount: '1000' }
        }
      };

      if (requirements.region) {
        placementProfile.attributes = [
          { key: 'region', value: requirements.region }
        ];
      }

      return {
        version: '2.0',
        services: {
          [requirements.name]: service
        },
        profiles: {
          compute: {
            [requirements.name]: computeProfile
          },
          placement: {
            [requirements.name]: placementProfile
          }
        },
        deployment: {
          [requirements.name]: {
            profile: requirements.name,
            count: requirements.count || 1
          }
        }
      };
    }

    /**
     * Generate SDL from template ID
     */
    export function generateFromTemplate(templateId: string): SdlSpec {
      const template = TEMPLATES.find(t => t.id === templateId);
      
      if (!template) {
        throw new Error(`Template not found: ${templateId}`);
      }
      
      return generateSDL(template.requirements);
    }

    /**
     * Validate SDL structure
     */
    export function validateSDL(sdl: SdlSpec): { valid: boolean; errors: string[] } {
      const errors: string[] = [];

      if (!sdl.version) {
        errors.push('Missing SDL version');
      }

      if (!sdl.services || Object.keys(sdl.services).length === 0) {
        errors.push('At least one service required');
      }

      for (const [name, service] of Object.entries(sdl.services)) {
        if (!service.image) {
          errors.push(`Service ${name}: missing image`);
        }
      }

      if (!sdl.profiles?.compute || Object.keys(sdl.profiles.compute).length === 0) {
        errors.push('Missing compute profiles');
      }

      if (!sdl.profiles?.placement || Object.keys(sdl.profiles.placement).length === 0) {
        errors.push('Missing placement profiles');
      }

      if (!sdl.deployment || Object.keys(sdl.deployment).length === 0) {
        errors.push('Missing deployment configuration');
      }

      return { valid: errors.length === 0, errors };
    }

    /**
     * Get all available templates
     */
    export function getTemplates(category?: SdlTemplate['category']): SdlTemplate[] {
      if (category) {
        return TEMPLATES.filter(t => t.category === category);
      }
      return [...TEMPLATES];
    }

    /**
     * Search templates by tags or name
     */
    export function searchTemplates(query: string): SdlTemplate[] {
      const lowerQuery = query.toLowerCase();
      return TEMPLATES.filter(t =>
        t.name.toLowerCase().includes(lowerQuery) ||
        t.description.toLowerCase().includes(lowerQuery) ||
        t.tags.some(tag => tag.toLowerCase().includes(lowerQuery))
      );
    }

    /**
     * Parse natural language to requirements
     * Simple keyword-based parser
     */
    export function parseNaturalLanguage(input: string): Partial<JobRequirements> {
      const requirements: Partial<JobRequirements> = {};
      const lower = input.toLowerCase();

      // Detect GPU needs
      if (lower.includes('gpu') || lower.includes('nvidia') || lower.includes('cuda')) {
        requirements.gpu = { units: 1 };
      }

      // Detect ML/AI frameworks
      if (lower.includes('pytorch') || lower.includes('torch')) {
        requirements.image = 'pytorch/pytorch:latest';
        requirements.name = 'pytorch';
      } else if (lower.includes('tensorflow') || lower.includes('tf')) {
        requirements.image = 'tensorflow/tensorflow:latest-gpu';
        requirements.name = 'tensorflow';
      } else if (lower.includes('jupyter') || lower.includes('notebook')) {
        requirements.image = 'jupyter/scipy-notebook:latest';
        requirements.name = 'jupyter';
      } else if (lower.includes('stable diffusion') || lower.includes('sd')) {
        requirements.image = 'neonstable/stable-diffusion-webui:latest';
        requirements.name = 'sd-webui';
        requirements.gpu = { units: 1, model: 'nvidia' };
      } else if (lower.includes('ollama') || lower.includes('llm')) {
        requirements.image = 'ollama/ollama:latest';
        requirements.name = 'ollama';
        requirements.gpu = { units: 1, model: 'nvidia' };
      }

      // Detect resource requirements
      const cpuMatch = lower.match(/(\d+)\s*cpu/);
      if (cpuMatch) {
        requirements.cpu = parseInt(cpuMatch[1], 10);
      }

      const memoryMatch = lower.match(/(\d+)\s*gb?\s*(ram|memory)/);
      if (memoryMatch) {
        requirements.memory = `${memoryMatch[1]}Gi`;
      }

      return requirements;
    }

    /**
     * Convert SDL to YAML string
     */
    export function sdlToYAML(sdl: SdlSpec): string {
      // Simple YAML serialization
      const indent = (level: number) => '  '.repeat(level);
      
      let yaml = `version: "${sdl.version}"\n\n`;
      
      yaml += 'services:\n';
      for (const [name, service] of Object.entries(sdl.services)) {
        yaml += `${indent(1)}${name}:\n`;
        yaml += `${indent(2)}image: ${service.image}\n`;
        
        if (service.command) {
          yaml += `${indent(2)}command:\n`;
          for (const cmd of service.command) {
            yaml += `${indent(3)}- ${cmd}\n`;
          }
        }
        
        if (service.args) {
          yaml += `${indent(2)}args:\n`;
          for (const arg of service.args) {
            yaml += `${indent(3)}- ${arg}\n`;
          }
        }
        
        if (service.env) {
          yaml += `${indent(2)}env:\n`;
          for (const env of service.env) {
            yaml += `${indent(3)}- ${env}\n`;
          }
        }
        
        if (service.expose.length > 0) {
          yaml += `${indent(2)}expose:\n`;
          for (const exp of service.expose) {
            yaml += `${indent(3)}- port: ${exp.port}\n`;
            yaml += `${indent(4)}as: ${exp.as}\n`;
            if (exp.to) {
              yaml += `${indent(4)}to:\n`;
              for (const to of exp.to) {
                yaml += `${indent(5)}- global: ${to.global}\n`;
              }
            }
          }
        }
      }
      
      yaml += '\nprofiles:\n';
      yaml += `${indent(1)}compute:\n`;
      for (const [name, profile] of Object.entries(sdl.profiles.compute)) {
        yaml += `${indent(2)}${name}:\n`;
        yaml += `${indent(3)}resources:\n`;
        yaml += `${indent(4)}cpu:\n`;
        yaml += `${indent(5)}units: ${profile.resources.cpu.units}\n`;
        yaml += `${indent(4)}memory:\n`;
        yaml += `${indent(5)}size: ${profile.resources.memory.size}\n`;
        
        if (profile.resources.storage.length > 0) {
          yaml += `${indent(4)}storage:\n`;
          for (const storage of profile.resources.storage) {
            yaml += `${indent(5)}- size: ${storage.size}\n`;
          }
        }
        
        if (profile.resources.gpu) {
          yaml += `${indent(4)}gpu:\n`;
          yaml += `${indent(5)}units: ${profile.resources.gpu.units}\n`;
          if (profile.resources.gpu.attributes) {
            yaml += `${indent(5)}attributes:\n`;
            for (const attr of profile.resources.gpu.attributes) {
              yaml += `${indent(6)}${attr.key}: ${attr.value}\n`;
            }
          }
        }
      }
      
      yaml += `${indent(1)}placement:\n`;
      for (const [name, placement] of Object.entries(sdl.profiles.placement)) {
        yaml += `${indent(2)}${name}:\n`;
        yaml += `${indent(3)}pricing:\n`;
        for (const [svc, price] of Object.entries(placement.pricing)) {
          yaml += `${indent(4)}${svc}:\n`;
          yaml += `${indent(5)}denom: ${price.denom}\n`;
          yaml += `${indent(5)}amount: ${price.amount}\n`;
        }
      }
      
      yaml += '\ndeployment:\n';
      for (const [name, config] of Object.entries(sdl.deployment)) {
        yaml += `${indent(1)}${name}:\n`;
        yaml += `${indent(2)}profile: ${config.profile}\n`;
        yaml += `${indent(2)}count: ${config.count}\n`;
      }
      
      return yaml;
    }
    ```
  </action>
  <verify>
    Run `npx eslint offchain/src/lib/akash/sdl-generator.ts` - no lint errors.
    Verify all templates have valid requirements.
    Test validateSDL with sample SDL specs.
  </verify>
  <done>
    SDL generator with 6 built-in templates.
    Natural language parser for requirements.
    YAML export functionality.
    Validation and search utilities.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create testnet USDC escrow contracts</name>
  <files>offchain/src/lib/contracts/testnet-usdc-token.ts, offchain/src/lib/contracts/testnet-usdc-escrow.ts</files>
  <action>
    **Create `offchain/src/lib/contracts/testnet-usdc-token.ts`:**

    ```typescript
    /**
     * Testnet USDC Token Integration
     * Uses fake/test USDC - NOT real money
     * For testing and demo purposes only
     */

    import { parseUnits, formatUnits } from 'viem';

    // Standard ERC20 ABI for USDC
    export const USDC_ABI = [
      {
        inputs: [],
        name: 'name',
        outputs: [{ name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [],
        name: 'symbol',
        outputs: [{ name: '', type: 'string' }],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [],
        name: 'decimals',
        outputs: [{ name: '', type: 'uint8' }],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [],
        name: 'totalSupply',
        outputs: [{ name: '', type: 'uint256' }],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [{ name: 'account', type: 'address' }],
        name: 'balanceOf',
        outputs: [{ name: '', type: 'uint256' }],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [
          { name: 'spender', type: 'address' },
          { name: 'amount', type: 'uint256' }
        ],
        name: 'approve',
        outputs: [{ name: '', type: 'bool' }],
        stateMutability: 'nonpayable',
        type: 'function'
      },
      {
        inputs: [
          { name: 'owner', type: 'address' },
          { name: 'spender', type: 'address' }
        ],
        name: 'allowance',
        outputs: [{ name: '', type: 'uint256' }],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' }
        ],
        name: 'transfer',
        outputs: [{ name: '', type: 'bool' }],
        stateMutability: 'nonpayable',
        type: 'function'
      },
      {
        inputs: [
          { name: 'sender', type: 'address' },
          { name: 'recipient', type: 'address' },
          { name: 'amount', type: 'uint256' }
        ],
        name: 'transferFrom',
        outputs: [{ name: '', type: 'bool' }],
        stateMutability: 'nonpayable',
        type: 'function'
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, name: 'owner', type: 'address' },
          { indexed: true, name: 'spender', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' }
        ],
        name: 'Approval',
        type: 'event'
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, name: 'from', type: 'address' },
          { indexed: true, name: 'to', type: 'address' },
          { indexed: false, name: 'value', type: 'uint256' }
        ],
        name: 'Transfer',
        type: 'event'
      }
    ] as const;

    export const USDC_ADDRESS = process.env.ADI_TESTNET_USDC_ADDRESS || '0x0000000000000000000000000000000000000000';

    export const USDC_DECIMALS = 6;

    /**
     * Format USDC amount for display
     */
    export function formatUSDC(amount: bigint): string {
      return formatUnits(amount, USDC_DECIMALS);
    }

    /**
     * Parse USDC amount from string
     */
    export function parseUSDC(amount: string): bigint {
      return parseUnits(amount, USDC_DECIMALS);
    }

    /**
     * Approve USDC spending
     * Returns the contract write configuration
     */
    export function approveUSDC(
      spender: string,
      amount: bigint
    ): {
      address: string;
      abi: typeof USDC_ABI;
      functionName: 'approve';
      args: [string, bigint];
    } {
      return {
        address: USDC_ADDRESS,
        abi: USDC_ABI,
        functionName: 'approve',
        args: [spender, amount]
      };
    }

    /**
     * Get USDC balance configuration for reading
     */
    export function getUSDCBalanceConfig(address: string) {
      return {
        address: USDC_ADDRESS,
        abi: USDC_ABI,
        functionName: 'balanceOf',
        args: [address]
      };
    }

    /**
     * Get USDC allowance configuration for reading
     */
    export function getUSDCAllowanceConfig(owner: string, spender: string) {
      return {
        address: USDC_ADDRESS,
        abi: USDC_ABI,
        functionName: 'allowance',
        args: [owner, spender]
      };
    }

    /**
     * Transfer USDC configuration
     */
    export function transferUSDC(
      recipient: string,
      amount: bigint
    ): {
      address: string;
      abi: typeof USDC_ABI;
      functionName: 'transfer';
      args: [string, bigint];
    } {
      return {
        address: USDC_ADDRESS,
        abi: USDC_ABI,
        functionName: 'transfer',
        args: [recipient, amount]
      };
    }

    /**
     * Check if USDC is properly configured
     */
    export function isUSDCConfigured(): boolean {
      return USDC_ADDRESS !== '0x0000000000000000000000000000000000000000';
    }

    /**
     * Get faucet URL for testnet USDC
     */
    export function getUSDCFaucetUrl(): string {
      // ADI Testnet faucet (https://faucet.ab.testnet.adifoundation.ai/)
      return 'https://faucet.circle.com/';
    }
    ```

    **Create `offchain/src/lib/contracts/testnet-usdc-escrow.ts`:**

    ```typescript
    /**
     * Testnet USDC Escrow Contract
     * Holds fake/test USDC on-chain, releases on deployment
     * NOT real money - for testing and demo only
     */

    import { parseUnits } from 'viem';

    // Escrow contract ABI
    export const ESCROW_ABI = [
      {
        inputs: [
          { name: '_usdcToken', type: 'address' }
        ],
        stateMutability: 'nonpayable',
        type: 'constructor'
      },
      {
        inputs: [
          { name: 'jobId', type: 'bytes32' },
          { name: 'amount', type: 'uint256' }
        ],
        name: 'deposit',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function'
      },
      {
        inputs: [
          { name: 'jobId', type: 'bytes32' }
        ],
        name: 'release',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function'
      },
      {
        inputs: [
          { name: 'jobId', type: 'bytes32' }
        ],
        name: 'refund',
        outputs: [],
        stateMutability: 'nonpayable',
        type: 'function'
      },
      {
        inputs: [
          { name: 'jobId', type: 'bytes32' }
        ],
        name: 'getEscrow',
        outputs: [{
          components: [
            { name: 'depositor', type: 'address' },
            { name: 'amount', type: 'uint256' },
            { name: 'status', type: 'uint8' },
            { name: 'createdAt', type: 'uint256' }
          ],
          name: '',
          type: 'tuple'
        }],
        stateMutability: 'view',
        type: 'function'
      },
      {
        inputs: [
          { name: 'jobId', type: 'bytes32' }
        ],
        name: 'escrows',
        outputs: [
          { name: 'depositor', type: 'address' },
          { name: 'amount', type: 'uint256' },
          { name: 'status', type: 'uint8' },
          { name: 'createdAt', type: 'uint256' }
        ],
        stateMutability: 'view',
        type: 'function'
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, name: 'jobId', type: 'bytes32' },
          { indexed: true, name: 'depositor', type: 'address' },
          { indexed: false, name: 'amount', type: 'uint256' }
        ],
        name: 'Deposited',
        type: 'event'
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, name: 'jobId', type: 'bytes32' }
        ],
        name: 'Released',
        type: 'event'
      },
      {
        anonymous: false,
        inputs: [
          { indexed: true, name: 'jobId', type: 'bytes32' },
          { indexed: false, name: 'amount', type: 'uint256' }
        ],
        name: 'Refunded',
        type: 'event'
      }
    ] as const;

    export const ESCROW_ADDRESS = process.env.ESCROW_CONTRACT_ADDRESS || '0x0000000000000000000000000000000000000000';

    export enum EscrowStatus {
      Active = 0,
      Released = 1,
      Refunded = 2
    }

    export interface Escrow {
      depositor: string;
      amount: bigint;
      status: EscrowStatus;
      createdAt: bigint;
    }

    /**
     * Deposit USDC into escrow for a job
     */
    export function depositEscrow(
      jobId: string,
      amount: bigint
    ): {
      address: string;
      abi: typeof ESCROW_ABI;
      functionName: 'deposit';
      args: [string, bigint];
    } {
      return {
        address: ESCROW_ADDRESS,
        abi: ESCROW_ABI,
        functionName: 'deposit',
        args: [jobId, amount]
      };
    }

    /**
     * Release escrowed funds to provider
     */
    export function releaseEscrow(
      jobId: string
    ): {
      address: string;
      abi: typeof ESCROW_ABI;
      functionName: 'release';
      args: [string];
    } {
      return {
        address: ESCROW_ADDRESS,
        abi: ESCROW_ABI,
        functionName: 'release',
        args: [jobId]
      };
    }

    /**
     * Refund escrowed funds to buyer
     */
    export function refundEscrow(
      jobId: string
    ): {
      address: string;
      abi: typeof ESCROW_ABI;
      functionName: 'refund';
      args: [string];
    } {
      return {
        address: ESCROW_ADDRESS,
        abi: ESCROW_ABI,
        functionName: 'refund',
        args: [jobId]
      };
    }

    /**
     * Get escrow details configuration
     */
    export function getEscrowConfig(jobId: string) {
      return {
        address: ESCROW_ADDRESS,
        abi: ESCROW_ABI,
        functionName: 'getEscrow',
        args: [jobId]
      };
    }

    /**
     * Calculate required deposit based on estimated duration
     * @param hourlyRate Hourly rate in USDC
     * @param hours Number of hours to pre-fund
     */
    export function calculateDepositAmount(hourlyRate: number, hours: number = 24): bigint {
      const total = hourlyRate * hours;
      return parseUnits(total.toString(), 6); // USDC has 6 decimals
    }

    /**
     * Check if escrow contract is configured
     */
    export function isEscrowConfigured(): boolean {
      return ESCROW_ADDRESS !== '0x0000000000000000000000000000000000000000';
    }

    /**
     * Format escrow status for display
     */
    export function formatEscrowStatus(status: EscrowStatus): string {
      switch (status) {
        case EscrowStatus.Active:
          return 'Active';
        case EscrowStatus.Released:
          return 'Released';
        case EscrowStatus.Refunded:
          return 'Refunded';
        default:
          return 'Unknown';
      }
    }
    ```
  </action>
  <verify>
    Run `npx eslint offchain/src/lib/contracts/testnet-usdc-token.ts` - no lint errors.
    Run `npx eslint offchain/src/lib/contracts/testnet-usdc-escrow.ts` - no lint errors.
    Verify viem imports are available.
    Check contract ABIs match standard ERC20 and escrow patterns.
  </verify>
  <done>
    Testnet USDC token interface created with full ERC20 ABI.
    Escrow contract interface with deposit, release, refund functions.
    Helper functions for amount calculations and formatting.
  </done>
</task>

</tasks>
