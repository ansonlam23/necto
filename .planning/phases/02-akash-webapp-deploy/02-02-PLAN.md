---
phase: 02-akash-webapp-deploy
plan: 02
type: execute
wave: 2
depends_on:
  - 02-01-PLAN.md
files_modified:
  - offchain/src/lib/agent/akash-router.ts
  - offchain/src/lib/agent/provider-selection.ts
  - offchain/src/components/akash/provider-card.tsx
  - offchain/src/components/akash/provider-list.tsx
  - offchain/src/components/akash/deployment-status.tsx
  - offchain/src/hooks/use-akash-deployment.ts
  - offchain/src/hooks/use-provider-discovery.ts
autonomous: false
user_setup:
  - service: Akash Console API
    why: "Real provider discovery and deployment routing"
    env_vars:
      - name: AKASH_CONSOLE_API_KEY
        source: "Akash Console dashboard"
must_haves:
  truths:
    - "Agent auto-routes suitable workloads to Akash based on job requirements"
    - "Multi-factor provider selection: latency, uptime, bid price, performance specs"
    - "Configurable suitability: Job characteristics determine if Akash is appropriate"
    - "Auto-sign enabled for streamlined hackathon/demo flow"
    - "Provider discovery includes filtering by GPU type, region, price, availability"
    - "Real-time bid polling with 5-minute timeout"
    - "Deployment status dashboard with state timeline"
    - "TypeScript strict mode with full type coverage"
  artifacts:
    - path: "offchain/src/lib/agent/akash-router.ts"
      provides: "Agent routing logic for Akash deployments"
      exports: ["routeToAkash", "isAkashSuitable", "AkashRouteResult"]
    - path: "offchain/src/lib/agent/provider-selection.ts"
      provides: "Multi-factor provider selection algorithm"
      exports: ["selectProvider", "rankProviders", "ProviderScore"]
    - path: "offchain/src/components/akash/provider-card.tsx"
      provides: "Individual provider display card"
      exports: ["ProviderCard", "CompactProviderCard"]
    - path: "offchain/src/components/akash/provider-list.tsx"
      provides: "Provider list with filtering and sorting"
      exports: ["ProviderList", "ProviderFilters"]
    - path: "offchain/src/components/akash/deployment-status.tsx"
      provides: "Deployment status dashboard component"
      exports: ["DeploymentStatus", "DeploymentTimeline"]
    - path: "offchain/src/hooks/use-akash-deployment.ts"
      provides: "React hook for deployment lifecycle"
      exports: ["useAkashDeployment", "DeploymentState"]
    - path: "offchain/src/hooks/use-provider-discovery.ts"
      provides: "React hook for provider discovery"
      exports: ["useProviderDiscovery", "DiscoveryFilters"]
  key_links:
    - from: "offchain/src/lib/agent/akash-router.ts"
      to: "offchain/src/lib/akash/console-api.ts"
      via: "Router uses Console API for deployment"
    - from: "offchain/src/lib/agent/provider-selection.ts"
      to: "offchain/src/lib/agent/akash-router.ts"
      via: "Router uses selection algorithm"
    - from: "offchain/src/hooks/use-akash-deployment.ts"
      to: "offchain/src/lib/agent/akash-router.ts"
      via: "Hook calls router for deployment"
---

<objective>
Implement agent routing logic for Akash deployments and create provider discovery UI. Enable auto-routing of suitable workloads with multi-factor provider selection and real-time deployment monitoring.

Purpose: Connect the agent to Akash Console API for automatic job routing, provider selection based on multiple criteria, and provide a rich UI for provider discovery and deployment status tracking.

Output: Complete agent routing system with provider selection algorithm, provider discovery UI components, and deployment monitoring hooks.
</objective>

<execution_context>
@/home/julius/.claude/get-shit-done/workflows/execute-plan.md
@/home/julius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@.planning/phases/02-akash-webapp-deploy/02-CONTEXT.md
@.planning/phases/02-akash-webapp-deploy/02-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement multi-factor provider selection</name>
  <files>offchain/src/lib/agent/provider-selection.ts</files>
  <action>
    **Create `offchain/src/lib/agent/provider-selection.ts`:**

    ```typescript
    /**
     * Provider Selection Algorithm
     * Multi-factor ranking based on latency, uptime, price, and specs
     */

    export interface Provider {
      id: string;
      name: string;
      address: string;
      region: string;
      gpuTypes: string[];
      pricePerHour: number; // In USD
      availability: number; // 0-1
      uptime: number; // Percentage
      latency?: number; // ms
      specs: {
        vcpus: number;
        memory: number; // GB
        storage: number; // GB
      };
    }

    export interface ProviderScore {
      provider: Provider;
      totalScore: number;
      priceScore: number;
      reliabilityScore: number;
      performanceScore: number;
      latencyScore: number;
    }

    export interface SelectionWeights {
      price: number;
      reliability: number;
      performance: number;
      latency: number;
    }

    const DEFAULT_WEIGHTS: SelectionWeights = {
      price: 0.35,
      reliability: 0.25,
      performance: 0.25,
      latency: 0.15
    };

    /**
     * Calculate price score (lower is better)
     * Uses inverse normalization
     */
    function calculatePriceScore(price: number, minPrice: number, maxPrice: number): number {
      if (maxPrice === minPrice) return 1;
      return 1 - ((price - minPrice) / (maxPrice - minPrice));
    }

    /**
     * Calculate reliability score from availability and uptime
     */
    function calculateReliabilityScore(availability: number, uptime: number): number {
      const availabilityWeight = 0.4;
      const uptimeWeight = 0.6;
      return (availability * availabilityWeight) + ((uptime / 100) * uptimeWeight);
    }

    /**
     * Calculate performance score from specs
     */
    function calculatePerformanceScore(
      specs: Provider['specs'],
      minSpecs: Provider['specs'],
      maxSpecs: Provider['specs']
    ): number {
      const vcpuScore = (specs.vcpus - minSpecs.vcpus) / (maxSpecs.vcpus - minSpecs.vcpus || 1);
      const memoryScore = (specs.memory - minSpecs.memory) / (maxSpecs.memory - minSpecs.memory || 1);
      const storageScore = (specs.storage - minSpecs.storage) / (maxSpecs.storage - minSpecs.storage || 1);
      
      return (vcpuScore + memoryScore + storageScore) / 3;
    }

    /**
     * Calculate latency score (lower is better)
     */
    function calculateLatencyScore(latency: number, minLatency: number, maxLatency: number): number {
      if (!latency) return 0.5; // Neutral if unknown
      if (maxLatency === minLatency) return 1;
      return 1 - ((latency - minLatency) / (maxLatency - minLatency));
    }

    /**
     * Rank providers by composite score
     */
    export function rankProviders(
      providers: Provider[],
      weights: SelectionWeights = DEFAULT_WEIGHTS
    ): ProviderScore[] {
      if (providers.length === 0) return [];

      // Calculate ranges for normalization
      const prices = providers.map(p => p.pricePerHour);
      const minPrice = Math.min(...prices);
      const maxPrice = Math.max(...prices);

      const vcpus = providers.map(p => p.specs.vcpus);
      const memory = providers.map(p => p.specs.memory);
      const storage = providers.map(p => p.specs.storage);

      const minSpecs = {
        vcpus: Math.min(...vcpus),
        memory: Math.min(...memory),
        storage: Math.min(...storage)
      };

      const maxSpecs = {
        vcpus: Math.max(...vcpus),
        memory: Math.max(...memory),
        storage: Math.max(...storage)
      };

      const latencies = providers
        .map(p => p.latency)
        .filter((l): l is number => l !== undefined);
      
      const minLatency = latencies.length > 0 ? Math.min(...latencies) : 0;
      const maxLatency = latencies.length > 0 ? Math.max(...latencies) : 100;

      // Score each provider
      const scored: ProviderScore[] = providers.map(provider => {
        const priceScore = calculatePriceScore(provider.pricePerHour, minPrice, maxPrice);
        const reliabilityScore = calculateReliabilityScore(provider.availability, provider.uptime);
        const performanceScore = calculatePerformanceScore(provider.specs, minSpecs, maxSpecs);
        const latencyScore = calculateLatencyScore(provider.latency || 0, minLatency, maxLatency);

        const totalScore = 
          (priceScore * weights.price) +
          (reliabilityScore * weights.reliability) +
          (performanceScore * weights.performance) +
          (latencyScore * weights.latency);

        return {
          provider,
          totalScore,
          priceScore,
          reliabilityScore,
          performanceScore,
          latencyScore
        };
      });

      // Sort by total score descending
      return scored.sort((a, b) => b.totalScore - a.totalScore);
    }

    /**
     * Select best provider from list
     */
    export function selectProvider(
      providers: Provider[],
      weights?: SelectionWeights
    ): Provider | null {
      const ranked = rankProviders(providers, weights);
      return ranked.length > 0 ? ranked[0].provider : null;
    }

    /**
     * Filter providers by requirements
     */
    export function filterProviders(
      providers: Provider[],
      filters: {
        gpuType?: string;
        region?: string;
        maxPrice?: number;
        minAvailability?: number;
        minVcpus?: number;
        minMemory?: number;
      }
    ): Provider[] {
      return providers.filter(p => {
        if (filters.gpuType && !p.gpuTypes.includes(filters.gpuType)) {
          return false;
        }
        if (filters.region && p.region !== filters.region) {
          return false;
        }
        if (filters.maxPrice && p.pricePerHour > filters.maxPrice) {
          return false;
        }
        if (filters.minAvailability && p.availability < filters.minAvailability) {
          return false;
        }
        if (filters.minVcpus && p.specs.vcpus < filters.minVcpus) {
          return false;
        }
        if (filters.minMemory && p.specs.memory < filters.minMemory) {
          return false;
        }
        return true;
      });
    }

    /**
     * Get provider recommendations with explanations
     */
    export function getProviderRecommendations(
      scored: ProviderScore[],
      limit: number = 3
    ): Array<{ provider: Provider; score: number; reason: string }> {
      return scored.slice(0, limit).map(s => {
        const strengths: string[] = [];
        
        if (s.priceScore > 0.8) strengths.push('best price');
        if (s.reliabilityScore > 0.8) strengths.push('high reliability');
        if (s.performanceScore > 0.8) strengths.push('great performance');
        if (s.latencyScore > 0.8) strengths.push('low latency');

        const reason = strengths.length > 0
          ? `Selected for ${strengths.join(', ')}`
          : 'Balanced overall score';

        return {
          provider: s.provider,
          score: s.totalScore,
          reason
        };
      });
    }
    ```
  </action>
  <verify>
    Run `npx eslint offchain/src/lib/agent/provider-selection.ts` - no lint errors.
    Test rankProviders with mock provider data.
    Verify filterProviders handles all filter criteria.
  </verify>
  <done>
    Multi-factor provider selection algorithm implemented.
    Configurable weights for price, reliability, performance, latency.
    Filtering and recommendation utilities.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create agent routing logic for Akash</name>
  <files>offchain/src/lib/agent/akash-router.ts</files>
  <action>
    **Create `offchain/src/lib/agent/akash-router.ts`:**

    ```typescript
    /**
     * Akash Agent Router
     * Routes suitable workloads to Akash providers
     * Handles bid polling and deployment lifecycle
     */

    import { SdlSpec, AkashDeployment, ProviderBid } from '@/types/akash';
    import {
      createDeployment,
      getDeploymentStatus,
      closeDeployment,
      getDeploymentBids,
      acceptProviderBid
    } from '@/lib/akash/console-api';
    import { generateSDL, JobRequirements } from '@/lib/akash/sdl-generator';
    import {
      selectProvider,
      rankProviders,
      filterProviders,
      Provider,
      ProviderScore
    } from './provider-selection';

    export interface RouteRequest {
      jobId: string;
      requirements: JobRequirements;
      autoAcceptBid?: boolean;
      bidTimeoutMs?: number;
    }

    export interface AkashRouteResult {
      success: boolean;
      deployment?: AkashDeployment;
      provider?: Provider;
      bids?: ProviderBid[];
      error?: string;
      logs: RouteLog[];
    }

    export interface RouteLog {
      timestamp: number;
      level: 'info' | 'warn' | 'error';
      message: string;
      details?: Record<string, unknown>;
    }

    export interface SuitabilityCheck {
      suitable: boolean;
      score: number;
      reasons: string[];
    }

    // Mock providers for development (replace with Console API)
    const MOCK_PROVIDERS: Provider[] = [
      {
        id: 'prov-1',
        name: 'GPU Cloud East',
        address: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb',
        region: 'us-east',
        gpuTypes: ['NVIDIA A100', 'NVIDIA V100'],
        pricePerHour: 2.50,
        availability: 0.95,
        uptime: 99.9,
        latency: 45,
        specs: { vcpus: 32, memory: 128, storage: 1000 }
      },
      {
        id: 'prov-2',
        name: 'Euro Compute',
        address: '0x8ba1f109551bD432803012645Hac136c82C3e8C',
        region: 'eu-west',
        gpuTypes: ['NVIDIA A100', 'NVIDIA RTX 4090'],
        pricePerHour: 2.20,
        availability: 0.92,
        uptime: 98.5,
        latency: 85,
        specs: { vcpus: 24, memory: 96, storage: 500 }
      },
      {
        id: 'prov-3',
        name: 'Asia GPU Hub',
        address: '0xdAC17F958D2ee523a2206206994597C13D831ec7',
        region: 'ap-south',
        gpuTypes: ['NVIDIA V100', 'NVIDIA RTX 3090'],
        pricePerHour: 1.80,
        availability: 0.88,
        uptime: 97.2,
        latency: 120,
        specs: { vcpus: 16, memory: 64, storage: 250 }
      },
      {
        id: 'prov-4',
        name: 'Premium West',
        address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
        region: 'us-west',
        gpuTypes: ['NVIDIA A100', 'NVIDIA H100'],
        pricePerHour: 3.50,
        availability: 0.98,
        uptime: 99.8,
        latency: 60,
        specs: { vcpus: 64, memory: 256, storage: 2000 }
      },
      {
        id: 'prov-5',
        name: 'Budget Compute',
        address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
        region: 'us-central',
        gpuTypes: ['NVIDIA RTX 4090', 'NVIDIA RTX 3090'],
        pricePerHour: 1.20,
        availability: 0.85,
        uptime: 96.8,
        latency: 55,
        specs: { vcpus: 12, memory: 48, storage: 500 }
      }
    ];

    /**
     * Check if a workload is suitable for Akash
     */
    export function isAkashSuitable(requirements: JobRequirements): SuitabilityCheck {
      const reasons: string[] = [];
      let score = 0;

      // GPU workloads are well-suited
      if (requirements.gpu && requirements.gpu.units > 0) {
        score += 0.3;
        reasons.push('GPU workloads ideal for Akash');
      }

      // Container-based workloads
      if (requirements.image) {
        score += 0.2;
        reasons.push('Container deployment supported');
      }

      // Stateful workloads less suitable
      if (requirements.storage && parseInt(requirements.storage) > 1000) {
        score -= 0.1;
        reasons.push('Large storage may be expensive on Akash');
      }

      // Short jobs are ideal
      if (!requirements.command?.some(c => c.includes('train') || c.includes('long'))) {
        score += 0.2;
        reasons.push('Suitable job duration');
      }

      // Web services work well
      if (requirements.port && requirements.expose) {
        score += 0.2;
        reasons.push('Web service deployment supported');
      }

      const suitable = score >= 0.5;
      
      if (!suitable) {
        reasons.push('Low suitability score - consider alternatives');
      }

      return { suitable, score: Math.min(1, Math.max(0, score)), reasons };
    }

    /**
     * Main routing function
     */
    export async function routeToAkash(
      request: RouteRequest,
      onProgress?: (log: RouteLog) => void
    ): Promise<AkashRouteResult> {
      const logs: RouteLog[] = [];
      
      const log = (level: RouteLog['level'], message: string, details?: Record<string, unknown>) => {
        const entry = { timestamp: Date.now(), level, message, details };
        logs.push(entry);
        onProgress?.(entry);
      };

      try {
        // Step 1: Check suitability
        log('info', 'Checking workload suitability for Akash');
        const suitability = isAkashSuitable(request.requirements);
        
        if (!suitability.suitable) {
          log('warn', 'Workload not ideal for Akash', { score: suitability.score });
        }

        // Step 2: Generate SDL
        log('info', 'Generating Akash SDL from requirements');
        const sdl = generateSDL(request.requirements);

        // Step 3: Select provider
        log('info', 'Discovering and ranking providers');
        const filters = {
          gpuType: request.requirements.gpu?.model,
          region: request.requirements.region,
          minVcpus: request.requirements.cpu,
          minMemory: request.requirements.memory ? parseInt(request.requirements.memory) : undefined
        };

        const filtered = filterProviders(MOCK_PROVIDERS, filters);
        
        if (filtered.length === 0) {
          log('error', 'No providers match requirements');
          return { success: false, error: 'No matching providers', logs };
        }

        const ranked = rankProviders(filtered);
        const selected = ranked[0];
        
        log('info', `Selected provider: ${selected.provider.name}`, {
          score: selected.totalScore,
          price: selected.provider.pricePerHour
        });

        // Step 4: Create deployment
        log('info', 'Creating deployment on Akash');
        const deployment = await createDeployment(sdl);
        
        log('info', `Deployment created: ${deployment.id}`, {
          dseq: deployment.dseq,
          status: deployment.status
        });

        // Step 5: Poll for bids
        const bidTimeout = request.bidTimeoutMs || 300000; // 5 minutes
        log('info', `Waiting for bids (timeout: ${bidTimeout}ms)`);
        
        const bids = await pollForBids(deployment.id, bidTimeout, (status) => {
          log('info', status);
        });

        if (bids.length === 0) {
          log('error', 'No bids received within timeout');
          await closeDeployment(deployment.id);
          return { 
            success: false, 
            error: 'No bids received - deployment cancelled',
            deployment,
            logs 
          };
        }

        log('info', `Received ${bids.length} bid(s)`, { bids: bids.map(b => b.provider) });

        // Step 6: Auto-accept or return bids
        if (request.autoAcceptBid && bids.length > 0) {
          log('info', 'Auto-accepting best bid');
          const bestBid = bids[0];
          await acceptProviderBid(deployment.id, bestBid.id);
          log('info', 'Bid accepted, lease created');
        }

        return {
          success: true,
          deployment,
          provider: selected.provider,
          bids,
          logs
        };

      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unknown error';
        log('error', `Routing failed: ${message}`);
        return { success: false, error: message, logs };
      }
    }

    /**
     * Poll for bids with timeout
     */
    async function pollForBids(
      deploymentId: string,
      timeoutMs: number,
      onStatus?: (status: string) => void
    ): Promise<ProviderBid[]> {
      const startTime = Date.now();
      const intervalMs = 10000; // 10 seconds

      while (Date.now() - startTime < timeoutMs) {
        const bids = await getDeploymentBids(deploymentId);
        
        if (bids.length > 0) {
          return bids;
        }

        onStatus?.(`Waiting for bids... (${Math.round((Date.now() - startTime) / 1000)}s)`);
        await new Promise(resolve => setTimeout(resolve, intervalMs));
      }

      return [];
    }

    /**
     * Cancel routing and cleanup
     */
    export async function cancelRoute(deploymentId?: string): Promise<void> {
      if (deploymentId) {
        try {
          await closeDeployment(deploymentId);
        } catch (error) {
          console.error('Failed to close deployment:', error);
        }
      }
    }

    /**
     * Get routing logs as formatted string
     */
    export function formatRouteLogs(logs: RouteLog[]): string {
      return logs.map(l => {
        const time = new Date(l.timestamp).toISOString();
        const emoji = l.level === 'error' ? '❌' : l.level === 'warn' ? '⚠️' : 'ℹ️';
        return `[${time}] ${emoji} ${l.message}`;
      }).join('\n');
    }
    ```
  </action>
  <verify>
    Run `npx eslint offchain/src/lib/agent/akash-router.ts` - no lint errors.
    Verify isAkashSuitable correctly evaluates workload types.
    Test routeToAkash with mock data.
  </verify>
  <done>
    Agent routing logic with suitability checking.
    Multi-step deployment flow with bid polling.
    Comprehensive logging and error handling.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create provider discovery hooks</name>
  <files>offchain/src/hooks/use-provider-discovery.ts, offchain/src/hooks/use-akash-deployment.ts</files>
  <action>
    **Create `offchain/src/hooks/use-provider-discovery.ts`:**

    ```typescript
    'use client';

    import { useState, useCallback, useEffect } from 'react';
    import { Provider, ProviderScore } from '@/lib/agent/provider-selection';

    export interface DiscoveryFilters {
      gpuType?: string;
      region?: string;
      maxPrice?: number;
      minAvailability?: number;
    }

    interface UseProviderDiscoveryReturn {
      providers: Provider[];
      ranked: ProviderScore[];
      isLoading: boolean;
      error: string | null;
      filters: DiscoveryFilters;
      setFilters: (filters: DiscoveryFilters) => void;
      refresh: () => Promise<void>;
      selectedProvider: Provider | null;
      setSelectedProvider: (provider: Provider | null) => void;
    }

    // Mock providers for initial development
    const MOCK_PROVIDERS: Provider[] = [
      {
        id: 'prov-1',
        name: 'GPU Cloud East',
        address: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb',
        region: 'us-east',
        gpuTypes: ['NVIDIA A100', 'NVIDIA V100'],
        pricePerHour: 2.50,
        availability: 0.95,
        uptime: 99.9,
        latency: 45,
        specs: { vcpus: 32, memory: 128, storage: 1000 }
      },
      {
        id: 'prov-2',
        name: 'Euro Compute',
        address: '0x8ba1f109551bD432803012645Hac136c82C3e8C',
        region: 'eu-west',
        gpuTypes: ['NVIDIA A100', 'NVIDIA RTX 4090'],
        pricePerHour: 2.20,
        availability: 0.92,
        uptime: 98.5,
        latency: 85,
        specs: { vcpus: 24, memory: 96, storage: 500 }
      },
      {
        id: 'prov-3',
        name: 'Asia GPU Hub',
        address: '0xdAC17F958D2ee523a2206206994597C13D831ec7',
        region: 'ap-south',
        gpuTypes: ['NVIDIA V100', 'NVIDIA RTX 3090'],
        pricePerHour: 1.80,
        availability: 0.88,
        uptime: 97.2,
        latency: 120,
        specs: { vcpus: 16, memory: 64, storage: 250 }
      }
    ];

    export function useProviderDiscovery(): UseProviderDiscoveryReturn {
      const [providers, setProviders] = useState<Provider[]>([]);
      const [ranked, setRanked] = useState<ProviderScore[]>([]);
      const [isLoading, setIsLoading] = useState(false);
      const [error, setError] = useState<string | null>(null);
      const [filters, setFilters] = useState<DiscoveryFilters>({});
      const [selectedProvider, setSelectedProvider] = useState<Provider | null>(null);

      const fetchProviders = useCallback(async () => {
        setIsLoading(true);
        setError(null);

        try {
          // TODO: Replace with real Console API call
          await new Promise(resolve => setTimeout(resolve, 800));
          
          // Apply filters
          let filtered = [...MOCK_PROVIDERS];
          
          if (filters.gpuType) {
            filtered = filtered.filter(p => 
              p.gpuTypes.includes(filters.gpuType!)
            );
          }
          
          if (filters.region) {
            filtered = filtered.filter(p => p.region === filters.region);
          }
          
          if (filters.maxPrice) {
            filtered = filtered.filter(p => 
              p.pricePerHour <= filters.maxPrice!
            );
          }
          
          if (filters.minAvailability) {
            filtered = filtered.filter(p => 
              p.availability >= filters.minAvailability!
            );
          }

          setProviders(filtered);

          // Rank providers
          const { rankProviders } = await import('@/lib/agent/provider-selection');
          const scored = rankProviders(filtered);
          setRanked(scored);

          // Auto-select top provider
          if (scored.length > 0 && !selectedProvider) {
            setSelectedProvider(scored[0].provider);
          }

        } catch (err) {
          setError(err instanceof Error ? err.message : 'Failed to fetch providers');
        } finally {
          setIsLoading(false);
        }
      }, [filters, selectedProvider]);

      useEffect(() => {
        fetchProviders();
      }, [fetchProviders]);

      return {
        providers,
        ranked,
        isLoading,
        error,
        filters,
        setFilters,
        refresh: fetchProviders,
        selectedProvider,
        setSelectedProvider
      };
    }
    ```

    **Create `offchain/src/hooks/use-akash-deployment.ts`:**

    ```typescript
    'use client';

    import { useState, useCallback } from 'react';
    import { AkashDeployment, ProviderBid } from '@/types/akash';
    import { JobRequirements } from '@/lib/akash/sdl-generator';
    import { RouteLog } from '@/lib/agent/akash-router';

    export type DeploymentState = 
      | 'idle'
      | 'checking_suitability'
      | 'generating_sdl'
      | 'selecting_provider'
      | 'creating_deployment'
      | 'waiting_bids'
      | 'accepting_bid'
      | 'active'
      | 'closing'
      | 'completed'
      | 'error';

    interface UseAkashDeploymentReturn {
      state: DeploymentState;
      deployment: AkashDeployment | null;
      bids: ProviderBid[];
      logs: RouteLog[];
      error: string | null;
      isLoading: boolean;
      progress: number;
      startDeployment: (requirements: JobRequirements, autoAccept?: boolean) => Promise<void>;
      acceptBid: (bidId: string) => Promise<void>;
      close: () => Promise<void>;
      reset: () => void;
    }

    const STATE_PROGRESS: Record<DeploymentState, number> = {
      idle: 0,
      checking_suitability: 10,
      generating_sdl: 20,
      selecting_provider: 35,
      creating_deployment: 50,
      waiting_bids: 65,
      accepting_bid: 80,
      active: 100,
      closing: 90,
      completed: 100,
      error: 0
    };

    export function useAkashDeployment(): UseAkashDeploymentReturn {
      const [state, setState] = useState<DeploymentState>('idle');
      const [deployment, setDeployment] = useState<AkashDeployment | null>(null);
      const [bids, setBids] = useState<ProviderBid[]>([]);
      const [logs, setLogs] = useState<RouteLog[]>([]);
      const [error, setError] = useState<string | null>(null);
      const [isLoading, setIsLoading] = useState(false);

      const addLog = useCallback((log: RouteLog) => {
        setLogs(prev => [...prev, log]);
      }, []);

      const startDeployment = useCallback(async (
        requirements: JobRequirements,
        autoAccept: boolean = false
      ) => {
        setIsLoading(true);
        setError(null);
        setLogs([]);
        setState('checking_suitability');

        try {
          const { routeToAkash } = await import('@/lib/agent/akash-router');
          
          const result = await routeToAkash(
            {
              jobId: `job-${Date.now()}`,
              requirements,
              autoAcceptBid: autoAccept,
              bidTimeoutMs: 300000 // 5 minutes
            },
            addLog
          );

          if (result.success && result.deployment) {
            setDeployment(result.deployment);
            setBids(result.bids || []);
            setState(result.bids && result.bids.length > 0 ? 'active' : 'waiting_bids');
          } else {
            setError(result.error || 'Deployment failed');
            setState('error');
          }
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Unknown error');
          setState('error');
        } finally {
          setIsLoading(false);
        }
      }, [addLog]);

      const acceptBid = useCallback(async (bidId: string) => {
        if (!deployment) return;

        setState('accepting_bid');
        setIsLoading(true);

        try {
          const { acceptProviderBid, getDeploymentBids } = await import('@/lib/akash/console-api');
          
          await acceptProviderBid(deployment.id, bidId);
          
          // Refresh bids to get updated status
          const updatedBids = await getDeploymentBids(deployment.id);
          setBids(updatedBids);
          setState('active');
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Failed to accept bid');
          setState('error');
        } finally {
          setIsLoading(false);
        }
      }, [deployment]);

      const close = useCallback(async () => {
        if (!deployment) return;

        setState('closing');
        setIsLoading(true);

        try {
          const { closeDeployment } = await import('@/lib/akash/console-api');
          await closeDeployment(deployment.id);
          setState('completed');
        } catch (err) {
          setError(err instanceof Error ? err.message : 'Failed to close deployment');
          setState('error');
        } finally {
          setIsLoading(false);
        }
      }, [deployment]);

      const reset = useCallback(() => {
        setState('idle');
        setDeployment(null);
        setBids([]);
        setLogs([]);
        setError(null);
        setIsLoading(false);
      }, []);

      return {
        state,
        deployment,
        bids,
        logs,
        error,
        isLoading,
        progress: STATE_PROGRESS[state],
        startDeployment,
        acceptBid,
        close,
        reset
      };
    }
    ```
  </action>
  <verify>
    Run `npx eslint offchain/src/hooks/use-provider-discovery.ts` - no lint errors.
    Run `npx eslint offchain/src/hooks/use-akash-deployment.ts` - no lint errors.
    Verify hook return types match interfaces.
  </verify>
  <done>
    useProviderDiscovery hook with filtering and ranking.
    useAkashDeployment hook with full lifecycle management.
    State machine with progress tracking.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create provider and deployment UI components</name>
  <files>offchain/src/components/akash/provider-card.tsx, offchain/src/components/akash/provider-list.tsx, offchain/src/components/akash/deployment-status.tsx</files>
  <action>
    **Create `offchain/src/components/akash/provider-card.tsx`:**

    ```tsx
    'use client';

    import * as React from 'react';
    import { cn } from '@/lib/utils';
    import { Provider, ProviderScore } from '@/lib/agent/provider-selection';
    import { Card, CardContent, CardHeader } from '@/components/ui/card';
    import { Badge } from '@/components/ui/badge';
    import { Button } from '@/components/ui/button';
    import { Progress } from '@/components/ui/progress';
    import { 
      Server, 
      Cpu, 
      HardDrive, 
      Globe, 
      Zap,
      DollarSign,
      Activity,
      Clock,
      CheckCircle2,
      Star
    } from 'lucide-react';

    interface ProviderCardProps {
      provider: Provider;
      score?: ProviderScore;
      isSelected?: boolean;
      onSelect?: () => void;
      showDetails?: boolean;
      className?: string;
    }

    export function ProviderCard({
      provider,
      score,
      isSelected,
      onSelect,
      showDetails = true,
      className
    }: ProviderCardProps) {
      return (
        <Card 
          className={cn(
            "transition-all duration-200 cursor-pointer",
            isSelected && "border-primary ring-2 ring-primary/20",
            className
          )}
          onClick={onSelect}
        >
          <CardHeader className="pb-2">
            <div className="flex items-start justify-between">
              <div className="flex items-center gap-2">
                <div className="p-2 rounded-lg bg-primary/10">
                  <Server className="h-5 w-5 text-primary" />
                </div>
                <div>
                  <h4 className="font-semibold">{provider.name}</h4>
                  <div className="flex items-center gap-1 text-xs text-muted-foreground">
                    <Globe className="h-3 w-3" />
                    {provider.region}
                  </div>
                </div>
              </div>
              {score && (
                <div className="flex items-center gap-1">
                  <Star className="h-4 w-4 text-yellow-500 fill-yellow-500" />
                  <span className="font-semibold">{(score.totalScore * 100).toFixed(0)}</span>
                </div>
              )}
            </div>
          </CardHeader>

          <CardContent className="space-y-3">
            {/* Price */}
            <div className="flex items-center justify-between">
              <div className="flex items-center gap-2 text-sm">
                <DollarSign className="h-4 w-4 text-green-500" />
                <span className="font-medium">${provider.pricePerHour.toFixed(2)}/hr</span>
              </div>
              <div className="flex items-center gap-2 text-sm">
                <Activity className="h-4 w-4 text-blue-500" />
                <span>{(provider.availability * 100).toFixed(0)}% avail</span>
              </div>
            </div>

            {/* GPU Types */}
            <div className="flex flex-wrap gap-1">
              {provider.gpuTypes.map(gpu => (
                <Badge key={gpu} variant="secondary" className="text-xs">
                  <Zap className="h-3 w-3 mr-1" />
                  {gpu}
                </Badge>
              ))}
            </div>

            {/* Specs */}
            {showDetails && (
              <div className="grid grid-cols-3 gap-2 pt-2 border-t">
                <div className="text-center">
                  <Cpu className="h-4 w-4 mx-auto mb-1 text-muted-foreground" />
                  <span className="text-xs font-medium">{provider.specs.vcpus} vCPU</span>
                </div>
                <div className="text-center">
                  <Server className="h-4 w-4 mx-auto mb-1 text-muted-foreground" />
                  <span className="text-xs font-medium">{provider.specs.memory}GB RAM</span>
                </div>
                <div className="text-center">
                  <HardDrive className="h-4 w-4 mx-auto mb-1 text-muted-foreground" />
                  <span className="text-xs font-medium">{provider.specs.storage}GB</span>
                </div>
              </div>
            )}

            {/* Score breakdown */}
            {score && showDetails && (
              <div className="space-y-2 pt-2 border-t">
                <div className="flex items-center justify-between text-xs">
                  <span>Price</span>
                  <Progress value={score.priceScore * 100} className="w-24 h-1" />
                </div>
                <div className="flex items-center justify-between text-xs">
                  <span>Reliability</span>
                  <Progress value={score.reliabilityScore * 100} className="w-24 h-1" />
                </div>
                <div className="flex items-center justify-between text-xs">
                  <span>Performance</span>
                  <Progress value={score.performanceScore * 100} className="w-24 h-1" />
                </div>
              </div>
            )}

            {/* Selection indicator */}
            {isSelected && (
              <div className="flex items-center justify-center gap-2 pt-2 text-sm text-primary border-t">
                <CheckCircle2 className="h-4 w-4" />
                Selected
              </div>
            )}
          </CardContent>
        </Card>
      );
    }

    interface CompactProviderCardProps {
      provider: Provider;
      isSelected?: boolean;
      onSelect?: () => void;
      className?: string;
    }

    export function CompactProviderCard({
      provider,
      isSelected,
      onSelect,
      className
    }: CompactProviderCardProps) {
      return (
        <div
          className={cn(
            "flex items-center gap-3 p-3 rounded-lg border transition-all cursor-pointer",
            isSelected && "border-primary bg-primary/5",
            className
          )}
          onClick={onSelect}
        >
          <div className="p-2 rounded-md bg-muted">
            <Server className="h-4 w-4" />
          </div>
          <div className="flex-1 min-w-0">
            <p className="font-medium truncate">{provider.name}</p>
            <p className="text-xs text-muted-foreground">
              {provider.region} • ${provider.pricePerHour.toFixed(2)}/hr
            </p>
          </div>
          {isSelected && <CheckCircle2 className="h-4 w-4 text-primary" />}
        </div>
      );
    }
    ```

    **Create `offchain/src/components/akash/provider-list.tsx`:**

    ```tsx
    'use client';

    import * as React from 'react';
    import { cn } from '@/lib/utils';
    import { useProviderDiscovery } from '@/hooks/use-provider-discovery';
    import { ProviderCard } from './provider-card';
    import { Input } from '@/components/ui/input';
    import { Label } from '@/components/ui/label';
    import {
      Select,
      SelectContent,
      SelectItem,
      SelectTrigger,
      SelectValue
    } from '@/components/ui/select';
    import { Slider } from '@/components/ui/slider';
    import { Loader2, Filter, RefreshCw } from 'lucide-react';
    import { Button } from '@/components/ui/button';

    interface ProviderListProps {
      className?: string;
      onSelect?: (providerId: string) => void;
      selectedId?: string;
    }

    const REGIONS = ['us-east', 'us-west', 'us-central', 'eu-west', 'eu-central', 'ap-south'];
    const GPU_TYPES = ['NVIDIA A100', 'NVIDIA V100', 'NVIDIA H100', 'NVIDIA RTX 4090', 'NVIDIA RTX 3090'];

    export function ProviderList({ className, onSelect, selectedId }: ProviderListProps) {
      const {
        ranked,
        isLoading,
        error,
        filters,
        setFilters,
        refresh,
        selectedProvider,
        setSelectedProvider
      } = useProviderDiscovery();

      const handleSelect = (providerId: string) => {
        const provider = ranked.find(r => r.provider.id === providerId)?.provider;
        if (provider) {
          setSelectedProvider(provider);
          onSelect?.(providerId);
        }
      };

      return (
        <div className={cn("space-y-4", className)}>
          {/* Filters */}
          <div className="space-y-4 p-4 rounded-lg border bg-card">
            <div className="flex items-center gap-2">
              <Filter className="h-4 w-4 text-muted-foreground" />
              <span className="font-medium">Filters</span>
            </div>

            <div className="grid gap-4 sm:grid-cols-2">
              <div className="space-y-2">
                <Label>Region</Label>
                <Select
                  value={filters.region || 'any'}
                  onValueChange={(value) => 
                    setFilters({ ...filters, region: value === 'any' ? undefined : value })
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Any region" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="any">Any region</SelectItem>
                    {REGIONS.map(r => (
                      <SelectItem key={r} value={r}>{r}</SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>

              <div className="space-y-2">
                <Label>GPU Type</Label>
                <Select
                  value={filters.gpuType || 'any'}
                  onValueChange={(value) => 
                    setFilters({ ...filters, gpuType: value === 'any' ? undefined : value })
                  }
                >
                  <SelectTrigger>
                    <SelectValue placeholder="Any GPU" />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="any">Any GPU</SelectItem>
                    {GPU_TYPES.map(g => (
                      <SelectItem key={g} value={g}>{g}</SelectItem>
                    ))}
                  </SelectContent>
                </Select>
              </div>
            </div>

            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label>Max Price</Label>
                <span className="text-sm text-muted-foreground">
                  ${filters.maxPrice?.toFixed(2) || 'No limit'}/hr
                </span>
              </div>
              <Slider
                value={[filters.maxPrice || 5]}
                onValueChange={([value]) => 
                  setFilters({ ...filters, maxPrice: value })
                }
                max={10}
                step={0.5}
              />
            </div>

            <div className="space-y-2">
              <div className="flex items-center justify-between">
                <Label>Min Availability</Label>
                <span className="text-sm text-muted-foreground">
                  {((filters.minAvailability || 0.8) * 100).toFixed(0)}%
                </span>
              </div>
              <Slider
                value={[filters.minAvailability || 0.8]}
                onValueChange={([value]) => 
                  setFilters({ ...filters, minAvailability: value })
                }
                max={1}
                step={0.05}
              />
            </div>

            <Button 
              variant="outline" 
              size="sm" 
              onClick={refresh}
              disabled={isLoading}
              className="w-full"
            >
              {isLoading ? (
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
              ) : (
                <RefreshCw className="h-4 w-4 mr-2" />
              )}
              Refresh
            </Button>
          </div>

          {/* Error */}
          {error && (
            <div className="p-4 rounded-lg border border-red-200 bg-red-50 text-red-800">
              {error}
            </div>
          )}

          {/* Provider List */}
          <div className="space-y-3">
            {isLoading ? (
              <div className="flex items-center justify-center py-8">
                <Loader2 className="h-8 w-8 animate-spin text-muted-foreground" />
              </div>
            ) : ranked.length === 0 ? (
              <div className="text-center py-8 text-muted-foreground">
                No providers match your filters
              </div>
            ) : (
              ranked.map(({ provider, totalScore }) => (
                <ProviderCard
                  key={provider.id}
                  provider={provider}
                  score={{ provider, totalScore, priceScore: 0, reliabilityScore: 0, performanceScore: 0, latencyScore: 0 }}
                  isSelected={provider.id === selectedId || provider.id === selectedProvider?.id}
                  onSelect={() => handleSelect(provider.id)}
                />
              ))
            )}
          </div>
        </div>
      );
    }
    ```

    **Create `offchain/src/components/akash/deployment-status.tsx`:**

    ```tsx
    'use client';

    import * as React from 'react';
    import { cn } from '@/lib/utils';
    import { DeploymentState, useAkashDeployment } from '@/hooks/use-akash-deployment';
    import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
    import { Progress } from '@/components/ui/progress';
    import { Badge } from '@/components/ui/badge';
    import { Button } from '@/components/ui/button';
    import { ScrollArea } from '@/components/ui/scroll-area';
    import {
      CheckCircle2,
      XCircle,
      Loader2,
      Clock,
      Server,
      FileCode,
      Search,
      Upload,
      Activity,
      AlertCircle
    } from 'lucide-react';

    interface DeploymentStatusProps {
      deployment: ReturnType<typeof useAkashDeployment>;
      className?: string;
    }

    const STATE_ICONS: Record<DeploymentState, React.ReactNode> = {
      idle: <Clock className="h-5 w-5" />,
      checking_suitability: <Search className="h-5 w-5" />,
      generating_sdl: <FileCode className="h-5 w-5" />,
      selecting_provider: <Search className="h-5 w-5" />,
      creating_deployment: <Upload className="h-5 w-5" />,
      waiting_bids: <Clock className="h-5 w-5" />,
      accepting_bid: <CheckCircle2 className="h-5 w-5" />,
      active: <Activity className="h-5 w-5" />,
      closing: <XCircle className="h-5 w-5" />,
      completed: <CheckCircle2 className="h-5 w-5" />,
      error: <AlertCircle className="h-5 w-5" />
    };

    const STATE_LABELS: Record<DeploymentState, string> = {
      idle: 'Ready',
      checking_suitability: 'Checking Suitability',
      generating_sdl: 'Generating SDL',
      selecting_provider: 'Selecting Provider',
      creating_deployment: 'Creating Deployment',
      waiting_bids: 'Waiting for Bids',
      accepting_bid: 'Accepting Bid',
      active: 'Active',
      closing: 'Closing',
      completed: 'Completed',
      error: 'Error'
    };

    const STATE_COLORS: Record<DeploymentState, string> = {
      idle: 'text-muted-foreground',
      checking_suitability: 'text-blue-500',
      generating_sdl: 'text-purple-500',
      selecting_provider: 'text-indigo-500',
      creating_deployment: 'text-orange-500',
      waiting_bids: 'text-yellow-500',
      accepting_bid: 'text-green-500',
      active: 'text-green-500',
      closing: 'text-orange-500',
      completed: 'text-green-500',
      error: 'text-red-500'
    };

    export function DeploymentStatus({ deployment, className }: DeploymentStatusProps) {
      const { state, progress, logs, error, deployment: deployData, isLoading } = deployment;

      return (
        <Card className={className}>
          <CardHeader>
            <div className="flex items-center justify-between">
              <CardTitle className="flex items-center gap-2">
                <Server className="h-5 w-5" />
                Deployment Status
              </CardTitle>
              <Badge 
                variant={state === 'error' ? 'destructive' : state === 'active' ? 'default' : 'secondary'}
              >
                {STATE_LABELS[state]}
              </Badge>
            </div>
          </CardHeader>

          <CardContent className="space-y-4">
            {/* Progress */}
            <div className="space-y-2">
              <div className="flex items-center justify-between text-sm">
                <span className={cn("flex items-center gap-2", STATE_COLORS[state])}>
                  {STATE_ICONS[state]}
                  {STATE_LABELS[state]}
                </span>
                <span className="text-muted-foreground">{progress}%</span>
              </div>
              <Progress value={progress} className="h-2" />
            </div>

            {/* Deployment Info */}
            {deployData && (
              <div className="p-3 rounded-lg bg-muted space-y-2">
                <div className="flex items-center justify-between text-sm">
                  <span className="text-muted-foreground">ID</span>
                  <span className="font-mono">{deployData.id.slice(0, 16)}...</span>
                </div>
                <div className="flex items-center justify-between text-sm">
                  <span className="text-muted-foreground">Status</span>
                  <Badge variant="outline">{deployData.status}</Badge>
                </div>
                <div className="flex items-center justify-between text-sm">
                  <span className="text-muted-foreground">Created</span>
                  <span>{new Date(deployData.createdAt).toLocaleString()}</span>
                </div>
              </div>
            )}

            {/* Error */}
            {error && (
              <div className="p-3 rounded-lg border border-red-200 bg-red-50 text-red-800 text-sm">
                <div className="flex items-center gap-2 font-medium">
                  <AlertCircle className="h-4 w-4" />
                  Error
                </div>
                <p className="mt-1">{error}</p>
              </div>
            )}

            {/* Logs */}
            {logs.length > 0 && (
              <div className="space-y-2">
                <h4 className="font-medium text-sm">Activity Log</h4>
                <ScrollArea className="h-48 rounded-lg border bg-muted p-3">
                  <div className="space-y-2">
                    {logs.map((log, i) => (
                      <div key={i} className="text-xs font-mono">
                        <span className="text-muted-foreground">
                          {new Date(log.timestamp).toLocaleTimeString()}
                        </span>
                        <span className={cn(
                          "ml-2",
                          log.level === 'error' && "text-red-500",
                          log.level === 'warn' && "text-yellow-500",
                          log.level === 'info' && "text-foreground"
                        )}>
                          {log.level.toUpperCase()}
                        </span>
                        <span className="ml-2">{log.message}</span>
                      </div>
                    ))}
                  </div>
                </ScrollArea>
              </div>
            )}

            {/* Actions */}
            {(state === 'active' || state === 'waiting_bids') && (
              <Button 
                variant="outline" 
                onClick={() => deployment.close()}
                disabled={isLoading}
                className="w-full"
              >
                {isLoading ? (
                  <Loader2 className="h-4 w-4 mr-2 animate-spin" />
                ) : (
                  <XCircle className="h-4 w-4 mr-2" />
                )}
                Close Deployment
              </Button>
            )}
          </CardContent>
        </Card>
      );
    }

    interface DeploymentTimelineProps {
      logs: { timestamp: number; message: string; level: string }[];
      className?: string;
    }

    export function DeploymentTimeline({ logs, className }: DeploymentTimelineProps) {
      return (
        <div className={cn("space-y-3", className)}>
          {logs.map((log, i) => (
            <div key={i} className="flex items-start gap-3">
              <div className={cn(
                "mt-1.5 h-2 w-2 rounded-full",
                log.level === 'error' ? 'bg-red-500' :
                log.level === 'warn' ? 'bg-yellow-500' :
                'bg-green-500'
              )} />
              <div className="flex-1">
                <p className="text-sm">{log.message}</p>
                <p className="text-xs text-muted-foreground">
                  {new Date(log.timestamp).toLocaleString()}
                </p>
              </div>
            </div>
          ))}
        </div>
      );
    }
    ```
  </action>
  <verify>
    Run `npx eslint offchain/src/components/akash/provider-card.tsx` - no lint errors.
    Run `npx eslint offchain/src/components/akash/provider-list.tsx` - no lint errors.
    Run `npx eslint offchain/src/components/akash/deployment-status.tsx` - no lint errors.
    Ensure all shadcn components used exist (Card, Badge, Button, Progress, Select, Slider, ScrollArea).
  </verify>
  <done>
    ProviderCard with detailed specs and scoring.
    ProviderList with filtering UI.
    DeploymentStatus with progress, logs, and timeline.
  </done>
</task>

</tasks>
