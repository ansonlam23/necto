---
phase: 01-foundation-core-agent
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - contracts/ComputeRouter.sol
  - contracts/types.ts
  - offchain/src/lib/adi-chain.ts
  - offchain/src/lib/wagmi.ts
  - .env.local
autonomous: true
user_setup:
  - service: ADI Testnet
    why: "Deploy ComputeRouter contract and fund agent wallet"
    env_vars:
      - name: ADI_TESTNET_RPC
        source: "ADI Chain documentation / faucet site"
      - name: AGENT_PRIVATE_KEY
        source: "Generate new wallet, fund from ADI faucet"
    dashboard_config:
      - task: "Fund agent wallet with ADI testnet tokens"
        location: "ADI Chain Faucet (URL in documentation)"
must_haves:
  truths:
    - "Agent can record job submission on-chain with job ID, user address, and hashes"
    - "Agent can record routing decision on-chain with selected provider and routing hash"
    - "Frontend can query job data from contract via read functions"
    - "Contract emits JobSubmitted and RoutingDecision events for off-chain indexing"
    - "Only whitelisted agent address can write to contract (security)"
    - "Contract supports both tracked and untracked submission modes"
  artifacts:
    - path: "contracts/ComputeRouter.sol"
      provides: "Smart contract with job recording and routing decision functions"
      exports: ["submitJob", "recordRoutingDecision", "getJob", "JobSubmitted", "RoutingDecision"]
    - path: "contracts/types.ts"
      provides: "TypeScript types and ABI for contract interaction"
      exports: ["ComputeRouterABI", "JobStatus", "Job", "RoutingDecision"]
    - path: "offchain/src/lib/adi-chain.ts"
      provides: "ADI Testnet chain configuration for viem/wagmi"
      exports: ["adiTestnet", "adiTestnetConfig"]
  key_links:
    - from: "offchain/src/lib/wagmi.ts"
      to: "offchain/src/lib/adi-chain.ts"
      via: "chain import"
      pattern: "import.*adiTestnet"
    - from: "contracts/ComputeRouter.sol"
      to: "contracts/types.ts"
      via: "ABI export"
      pattern: "export.*ComputeRouterABI"
---

<objective>
Deploy ComputeRouter.sol to ADI Testnet — a minimal job registry that stores job IDs and 0G Storage hashes on-chain while keeping full metadata off-chain. This contract provides the immutable audit trail foundation for Phase 1 buyer discovery.

Purpose: Enable verifiable routing decisions from day 1 by storing job creation and routing hashes on-chain, with full reasoning available via 0G Storage lookup. Supports both tracked (identified) and untracked (privacy) job submissions.
Output: Deployed contract on ADI Testnet with TypeScript ABI/types integration
</objective>

<execution_context>
@/home/julius/.config/opencode/get-shit-done/workflows/execute-plan.md
@/home/julius/.config/opencode/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-agent/01-CONTEXT.md
@offchain/src/lib/wagmi.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ComputeRouter.sol contract</name>
  <files>contracts/ComputeRouter.sol</files>
  <action>
    Create ComputeRouter.sol with the following design per user decisions (LOCKED):
    
    **Contract Structure:**
    - Use Solidity ^0.8.19
    - Minimal on-chain storage: job ID + hashes only
    - Whitelist pattern for agent write access (constructor sets initial agent)
    
    **Data Structures:**
    ```solidity
    struct Job {
        uint256 id;
        address user;           // zero address for untracked mode
        bytes32 detailsHash;    // points to 0G Storage for full metadata
        bytes32 routingHash;    // points to 0G Storage for agent reasoning
        address provider;       // selected provider (set on routing)
        uint256 amount;         // price in smallest unit (set on routing)
        bool isTracked;         // tracked vs untracked mode
        uint256 createdAt;
        uint256 routedAt;
    }
    ```
    
    **State Variables:**
    - mapping(uint256 => Job) public jobs
    - uint256 public jobCounter
    - address public agent
    - mapping(address => bool) public authorizedAgents (for future multi-agent)
    
    **Events:**
    - JobSubmitted(uint256 indexed jobId, address indexed user, bytes32 detailsHash, bool isTracked)
    - RoutingDecision(uint256 indexed jobId, address indexed provider, uint256 amount, bytes32 routingHash)
    
    **Functions:**
    - constructor(address _initialAgent)
    - submitJob(address _user, bytes32 _detailsHash, bool _isTracked) external onlyAgent → returns uint256 jobId
    - recordRoutingDecision(uint256 _jobId, address _provider, uint256 _amount, bytes32 _routingHash) external onlyAgent
    - getJob(uint256 _jobId) external view returns (Job memory)
    - updateAgent(address _newAgent) external onlyAgent (for rotation)
    
    **Security:**
    - onlyAgent modifier checks msg.sender == agent
    - Validate job exists before recording routing decision
    - Prevent double-routing (check routedAt == 0)
    
    **Gas Optimization (Claude's discretion):**
    - Pack struct fields where possible
    - Use calldata for external function params
    - Minimize storage writes (only 2 writes per job: submit + route)
    
    **Future-Proofing (Phase 3 ready):**
    - Leave room for status enum (Submitted → Routed → [Active → Completed in Phase 3])
    - Amount field present for future escrow integration
  </action>
  <verify>npx solhint contracts/ComputeRouter.sol (no critical errors)</verify>
  <done>Contract compiles without errors, implements all required functions and events, includes security modifiers</done>
</task>

<task type="auto">
  <name>Task 2: Generate TypeScript types and ABI</name>
  <files>contracts/types.ts</files>
  <action>
    Create TypeScript types file for contract integration:
    
    **ABI Export:**
    - Export ComputeRouterABI as const array matching contract interface
    - Include all functions: submitJob, recordRoutingDecision, getJob, updateAgent
    - Include all events: JobSubmitted, RoutingDecision
    - Include all view functions: jobCounter, agent, authorizedAgents, jobs
    
    **TypeScript Interfaces:**
    ```typescript
    export interface Job {
      id: bigint;
      user: `0x${string}`;
      detailsHash: `0x${string}`;
      routingHash: `0x${string}`;
      provider: `0x${string}`;
      amount: bigint;
      isTracked: boolean;
      createdAt: bigint;
      routedAt: bigint;
    }
    
    export type JobSubmittedEvent = {
      jobId: bigint;
      user: `0x${string}`;
      detailsHash: `0x${string}`;
      isTracked: boolean;
    };
    
    export type RoutingDecisionEvent = {
      jobId: bigint;
      provider: `0x${string}`;
      amount: bigint;
      routingHash: `0x${string}`;
    };
    ```
    
    **Contract Addresses:**
    - Export ADI_TESTNET_CONTRACT_ADDRESS (empty string, filled after deployment)
    
    **Helper Types:**
    - ComputeRouterFunctionNames union type
    - ComputeRouterEventNames union type
  </action>
  <verify>Types match contract interface exactly, no TypeScript errors</verify>
  <done>TypeScript types exported, ABI matches contract functions/events, ready for frontend integration</done>
</task>

<task type="auto">
  <name>Task 3: Configure ADI Testnet chain and update wagmi</name>
  <files>offchain/src/lib/adi-chain.ts, offchain/src/lib/wagmi.ts</files>
  <action>
    **Create offchain/src/lib/adi-chain.ts:**
    
    **Update offchain/src/lib/wagmi.ts:**
    - Import adiTestnet from ./adi-chain
    - Add adiTestnet to chains array in createConfig
    - Add http transport for adiTestnet.id
    - Keep existing mainnet/sepolia for other uses
    - Export ADI_TESTNET_AGENT_WALLET (read from env or placeholder)
    
    **Environment Setup:**
    - Update .env.local with:
      - ADI_TESTNET_RPC= (RPC endpoint)
      - AGENT_PRIVATE_KEY= (agent wallet private key)
      - CONTRACT_ADDRESS= (filled after deployment)
    
    **Note:** Contract deployment itself requires manual step with funded wallet.
    The plan creates deployment-ready configuration; actual deployment is human-action
    due to wallet funding requirement from ADI faucet.
  </action>
  <verify>wagmi.ts imports adi-chain without errors, chain config has required fields</verify>
  <done>ADI Testnet configured in wagmi, environment variables documented, ready for deployment</done>
</task>

</tasks>

<verification>
**Contract Completeness:**
- [ ] ComputeRouter.sol compiles with solc ^0.8.19
- [ ] All required functions implemented: submitJob, recordRoutingDecision, getJob
- [ ] All required events defined: JobSubmitted, RoutingDecision
- [ ] OnlyAgent modifier restricts writes to whitelisted agent
- [ ] Tracked/untracked mode supported via isTracked boolean
- [ ] Job struct includes all required fields per user decisions

**Type Safety:**
- [ ] TypeScript types match Solidity interface exactly
- [ ] ABI exports all functions and events
- [ ] No `any` types in contract interface

**Integration Readiness:**
- [ ] ADI Testnet chain configured in viem/wagmi
- [ ] Environment variables documented in .env.local
- [ ] Contract address export ready for post-deployment

**Security:**
- [ ] Agent whitelist prevents unauthorized writes
- [ ] Job existence validation on routing
- [ ] No reentrancy risk (no external calls to untrusted contracts)
</verification>

<success_criteria>
1. **Contract Code:** ComputeRouter.sol exists with submitJob, recordRoutingDecision, getJob functions
2. **Event Emission:** JobSubmitted and RoutingDecision events defined with indexed params
3. **Access Control:** Only whitelisted agent can call write functions
4. **Type Integration:** TypeScript types and ABI exported in contracts/types.ts
5. **Chain Config:** ADI Testnet configured and added to wagmi.ts
6. **Deployment Ready:** Environment variables documented, contract ready for ADI Testnet deployment
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-agent/01-01-SUMMARY.md`
</output>
