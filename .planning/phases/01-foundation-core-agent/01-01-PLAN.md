---
phase: 01-foundation-core-agent
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - hardhat/contracts/ComputeRouter.sol
  - hardhat/test/ComputeRouter.ts
  - hardhat/ignition/modules/ComputeRouter.ts
  - hardhat/scripts/interact-router.ts
  - offchain/src/lib/contracts/compute-router.ts
  - offchain/src/lib/adi-chain.ts
  - offchain/src/lib/wagmi.ts
autonomous: true
user_setup:
  - service: ADI Testnet
    why: "Deploy ComputeRouter contract and fund agent wallet"
    env_vars:
      - name: TESTNET_PRIVATE_KEY
        source: "Generate new wallet, fund from ADI faucet"
    dashboard_config:
      - task: "Fund agent wallet with ADI testnet tokens"
        location: "ADI Chain Faucet (URL in documentation)"
must_haves:
  truths:
    - "Agent can record job submission on-chain with job ID, user address, and detailsHash"
    - "Agent can record routing decision on-chain with selected provider, amount, and routingHash"
    - "Anyone can query job data from contract via read functions (open read access)"
    - "Contract emits JobSubmitted and RoutingDecision events with indexed params for off-chain indexing"
    - "Only whitelisted agent address can call write functions (onlyAgent modifier)"
    - "Contract supports both tracked (user address stored) and untracked (zero address) submission modes"
    - "All tests pass using `npx hardhat test` in hardhat/ directory"
    - "Ignition deployment module exists and can deploy to ADI Testnet"
  artifacts:
    - path: "hardhat/contracts/ComputeRouter.sol"
      provides: "Smart contract with job recording and routing decision functions"
      exports: ["submitJob", "recordRoutingDecision", "getJob", "getJobCount", "JobSubmitted", "RoutingDecision"]
    - path: "hardhat/test/ComputeRouter.ts"
      provides: "Comprehensive test suite using viem + node:test"
      exports: ["describe ComputeRouter"]
    - path: "hardhat/ignition/modules/ComputeRouter.ts"
      provides: "Hardhat Ignition deployment module"
      exports: ["default buildModule"]
    - path: "offchain/src/lib/contracts/compute-router.ts"
      provides: "TypeScript ABI, types, and contract address for frontend integration"
      exports: ["COMPUTE_ROUTER_ABI", "COMPUTE_ROUTER_ADDRESS", "Job", "JobSubmittedEvent", "RoutingDecisionEvent"]
    - path: "offchain/src/lib/adi-chain.ts"
      provides: "ADI Testnet chain definition for viem/wagmi"
      exports: ["adiTestnet"]
    - path: "offchain/src/lib/wagmi.ts"
      provides: "Updated wagmi config including ADI Testnet chain"
      exports: ["config"]
  key_links:
    - from: "offchain/src/lib/wagmi.ts"
      to: "offchain/src/lib/adi-chain.ts"
      via: "chain import"
      pattern: "import.*adiTestnet"
    - from: "offchain/src/lib/contracts/compute-router.ts"
      to: "hardhat/contracts/ComputeRouter.sol"
      via: "ABI matches contract interface"
      pattern: "COMPUTE_ROUTER_ABI"
    - from: "hardhat/ignition/modules/ComputeRouter.ts"
      to: "hardhat/contracts/ComputeRouter.sol"
      via: "Ignition module deploys contract"
      pattern: "m.contract.*ComputeRouter"
---

<objective>
Implement ComputeRouter.sol smart contract in the existing Hardhat 3 project, with comprehensive tests, Ignition deployment module, and TypeScript ABI/types export for offchain integration. Deploy-ready for ADI Testnet.

Purpose: Enable verifiable routing decisions from day 1 by storing job creation and routing decision hashes on-chain, with full reasoning available via 0G Storage lookup. This is the immutable audit trail foundation for the entire marketplace. Supports both tracked (identified) and untracked (privacy-preserving) job submissions.

Output: Compiled contract, passing test suite, Ignition deployment module, and TypeScript types/ABI ready for offchain consumption.
</objective>

<execution_context>
@/home/julius/.claude/get-shit-done/workflows/execute-plan.md
@/home/julius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-core-agent/01-CONTEXT.md
@hardhat/hardhat.config.ts
@hardhat/contracts/Counter.sol
@hardhat/test/Counter.ts
@hardhat/ignition/modules/Counter.ts
@hardhat/scripts/increment.ts
@offchain/src/lib/wagmi.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Implement ComputeRouter.sol contract and test suite</name>
  <files>hardhat/contracts/ComputeRouter.sol, hardhat/test/ComputeRouter.ts</files>
  <action>
    **Create `hardhat/contracts/ComputeRouter.sol`** with the following design per user LOCKED decisions:

    **Pragma:** `pragma solidity ^0.8.28;` (matches hardhat.config.ts)
    **License:** SPDX-License-Identifier: UNLICENSED (matches Counter.sol pattern)

    **Immutable contract** (no proxy pattern — Claude's discretion: hackathon timeline favors simplicity; redeployment is cheap on testnet).

    **Data Structures:**
    ```solidity
    struct Job {
        uint256 id;
        address user;           // zero address (address(0)) for untracked mode
        bytes32 detailsHash;    // points to 0G Storage for full job request metadata
        bytes32 routingHash;    // points to 0G Storage for agent reasoning (set on routing)
        address provider;       // selected provider address (set on routing)
        uint256 amount;         // price in wei or smallest unit (set on routing)
        bool isTracked;         // tracked vs untracked mode
        uint256 createdAt;      // block.timestamp at submission
        uint256 routedAt;       // block.timestamp at routing (0 until routed)
    }
    ```

    **State Variables:**
    - `mapping(uint256 => Job) private jobs` (private mapping, access via getJob)
    - `uint256 public jobCount` (counter for job IDs, starts at 0, first job is ID 1)
    - `address public agent` (whitelisted agent address)

    NOTE: Skip the `authorizedAgents` mapping from the old plan. Single agent is sufficient for Phase 1. Multi-agent is Phase 3+ scope. Keep it simple.

    **Events:**
    ```solidity
    event JobSubmitted(uint256 indexed jobId, address indexed user, bytes32 detailsHash, bool isTracked);
    event RoutingDecision(uint256 indexed jobId, address indexed provider, uint256 amount, bytes32 routingHash);
    event AgentUpdated(address indexed oldAgent, address indexed newAgent);
    ```

    **Modifier:**
    ```solidity
    modifier onlyAgent() {
        require(msg.sender == agent, "ComputeRouter: caller is not the agent");
        _;
    }
    ```

    **Functions:**

    1. `constructor(address _agent)` — Sets initial agent. Require `_agent != address(0)`.

    2. `submitJob(address _user, bytes32 _detailsHash, bool _isTracked) external onlyAgent returns (uint256)`
       - Increments jobCount, uses new value as jobId (so first job is ID 1)
       - If `_isTracked` is false, store `address(0)` as user regardless of `_user` param (enforce privacy)
       - If `_isTracked` is true, store `_user` as-is
       - Sets `createdAt = block.timestamp`
       - Leaves `routingHash`, `provider`, `amount`, `routedAt` at default (zero)
       - Emits `JobSubmitted(jobId, storedUser, _detailsHash, _isTracked)`
       - Returns `jobId`

    3. `recordRoutingDecision(uint256 _jobId, address _provider, uint256 _amount, bytes32 _routingHash) external onlyAgent`
       - Require `_jobId > 0 && _jobId <= jobCount` (job exists)
       - Require `jobs[_jobId].routedAt == 0` (not already routed — prevent double-routing)
       - Require `_provider != address(0)` (valid provider)
       - Require `_routingHash != bytes32(0)` (valid hash)
       - Sets provider, amount, routingHash, routedAt on the job
       - Emits `RoutingDecision(_jobId, _provider, _amount, _routingHash)`

    4. `getJob(uint256 _jobId) external view returns (Job memory)`
       - Require `_jobId > 0 && _jobId <= jobCount` (job exists)
       - Returns full Job struct

    5. `updateAgent(address _newAgent) external onlyAgent`
       - Require `_newAgent != address(0)`
       - Emit `AgentUpdated(agent, _newAgent)`
       - Set `agent = _newAgent`

    **Gas Optimization (Claude's discretion):**
    - Use `calldata` for external function string/bytes params (none here — all value types)
    - Struct packing: bool + address can pack into one slot but Solidity auto-handles this with the optimizer enabled in production profile
    - Only 2 storage writes per job lifecycle (submit + route) — already minimal

    ---

    **Create `hardhat/test/ComputeRouter.ts`** following the Counter.ts pattern exactly:

    Use `import assert from "node:assert/strict"` and `import { describe, it } from "node:test"`.
    Use `import { network } from "hardhat"` then `const { viem } = await network.connect()`.
    Use `viem.deployContract("ComputeRouter", [agentAddress])` pattern.
    Use `viem.assertions.emitWithArgs()` for event verification.
    Use `publicClient.getContractEvents()` for event querying.

    **Test cases to implement:**

    1. **Deployment tests:**
       - Sets agent address correctly on deployment
       - Rejects deployment with zero address agent (use try/catch or assert.rejects)

    2. **submitJob tests:**
       - Agent can submit a tracked job (isTracked=true) — verify stored user address
       - Agent can submit an untracked job (isTracked=false) — verify user is address(0)
       - Emits JobSubmitted event with correct args (use `viem.assertions.emitWithArgs`)
       - Job counter increments correctly (submit 2 jobs, verify IDs are 1 and 2)
       - Non-agent cannot submit job (use second wallet client, expect revert)

    3. **recordRoutingDecision tests:**
       - Agent can record routing decision on submitted job
       - Emits RoutingDecision event with correct args
       - Cannot route non-existent job (jobId 999)
       - Cannot double-route a job (route once, try again, expect revert)
       - Cannot route with zero address provider
       - Cannot route with zero bytes32 routingHash
       - Non-agent cannot record routing decision

    4. **getJob tests:**
       - Returns correct data for submitted (unrouted) job
       - Returns correct data for routed job
       - Reverts for non-existent job ID (jobId 0, jobId > jobCount)

    5. **updateAgent tests:**
       - Agent can update to new agent address
       - Emits AgentUpdated event
       - New agent can call submitJob (old agent cannot)
       - Cannot update to zero address

    6. **Integration test:**
       - Full lifecycle: deploy → submit tracked job → record routing → verify via getJob
       - Full lifecycle: deploy → submit untracked job → verify user is zero address → route → verify

    **Important pattern notes from Counter.ts:**
    - Get wallet clients via `const [agentClient] = await viem.getWalletClients()` (first account)
    - For non-agent tests, use a different wallet client or the publicClient
    - The viem test helpers in Hardhat 3 use `contract.write.functionName([args])` pattern
    - Read functions use `contract.read.functionName([args])` pattern
    - For revert testing: wrap in try/catch and assert the call throws, or use assert.rejects
  </action>
  <verify>
    Run `cd /home/julius/Documents/necto/hardhat && npx hardhat test` — all tests pass with zero failures.
    Run `cd /home/julius/Documents/necto/hardhat && npx hardhat compile` — no compilation errors.
  </verify>
  <done>
    ComputeRouter.sol compiles without errors. All test cases pass: deployment, submitJob (tracked + untracked), recordRoutingDecision (success + all reverts), getJob, updateAgent, and full integration lifecycle. Events verified with correct indexed args.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Ignition deployment module and interaction script</name>
  <files>hardhat/ignition/modules/ComputeRouter.ts, hardhat/scripts/interact-router.ts</files>
  <action>
    **Create `hardhat/ignition/modules/ComputeRouter.ts`** following the Counter.ts Ignition pattern:

    ```typescript
    import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";

    export default buildModule("ComputeRouterModule", (m) => {
      // Agent address passed as module parameter with a default
      // The deployer's address will be the initial agent
      // Override at deploy time: --parameters '{"ComputeRouterModule#ComputeRouter": {"_agent": "0x..."}}'
      const agentAddress = m.getParameter("agentAddress");

      const computeRouter = m.contract("ComputeRouter", [agentAddress]);

      return { computeRouter };
    });
    ```

    NOTE: The `agentAddress` parameter must be provided at deploy time. The deployer should pass their own address or a dedicated agent wallet address. Document this in the module comments.

    Deploy command (for reference in comments):
    ```bash
    npx hardhat ignition deploy --network adiTestnet ignition/modules/ComputeRouter.ts --parameters '{"ComputeRouterModule": {"agentAddress": "0xYOUR_AGENT_ADDRESS"}}'
    ```

    ---

    **Create `hardhat/scripts/interact-router.ts`** following the increment.ts pattern:

    This script demonstrates interacting with a deployed ComputeRouter contract on ADI Testnet. It:
    1. Connects to ADI Testnet using `network.connect('adiTestnet')`
    2. Gets publicClient and walletClient (same pattern as increment.ts)
    3. Defines `CONTRACT_ADDRESS` constant (to be filled after deployment)
    4. Gets contract instance via `viem.getContractAt('ComputeRouter', CONTRACT_ADDRESS, ...)`
    5. Reads current jobCount
    6. Submits a test job (tracked mode, with a sample detailsHash)
    7. Records a routing decision on that job
    8. Reads back the job via getJob and logs all fields
    9. Queries JobSubmitted and RoutingDecision events

    Use the same `defineChain` pattern from increment.ts for the ADI chain definition:
    ```typescript
    const adiChain = defineChain({
      id: 99999,
      name: 'ADI Chain',
      network: 'adiTestnet',
      nativeCurrency: { name: 'ADI', symbol: 'ADI', decimals: 18 },
      rpcUrls: { default: { http: ['https://rpc.ab.testnet.adifoundation.ai'] } },
    });
    ```

    Use `publicClient.waitForTransactionReceipt({ hash: tx })` after each write call.
    Log each step clearly with console.log for debugging.
  </action>
  <verify>
    Verify Ignition module compiles: `cd /home/julius/Documents/necto/hardhat && npx hardhat compile` succeeds.
    Verify script has no TypeScript errors: `cd /home/julius/Documents/necto/hardhat && npx hardhat run scripts/interact-router.ts` (will fail at runtime without deployed contract, but should have no compilation errors — check for TS errors only).
  </verify>
  <done>
    Ignition module created with parameterized agent address. Interaction script created following established increment.ts pattern. Both files have no TypeScript errors. Deployment command documented in comments.
  </done>
</task>

<task type="auto">
  <name>Task 3: Export TypeScript ABI/types and configure ADI Testnet in wagmi</name>
  <files>offchain/src/lib/contracts/compute-router.ts, offchain/src/lib/adi-chain.ts, offchain/src/lib/wagmi.ts</files>
  <action>
    **Create `offchain/src/lib/contracts/compute-router.ts`:**

    This file exports the contract ABI, types, and address for use by the offchain frontend and API routes.

    Export `COMPUTE_ROUTER_ABI` as a `const` array (viem requires `as const` for type inference). The ABI must exactly match ComputeRouter.sol's interface:
    - constructor(address _agent)
    - function submitJob(address _user, bytes32 _detailsHash, bool _isTracked) external returns (uint256)
    - function recordRoutingDecision(uint256 _jobId, address _provider, uint256 _amount, bytes32 _routingHash) external
    - function getJob(uint256 _jobId) external view returns (tuple)
    - function updateAgent(address _newAgent) external
    - function jobCount() external view returns (uint256)
    - function agent() external view returns (address)
    - event JobSubmitted(uint256 indexed jobId, address indexed user, bytes32 detailsHash, bool isTracked)
    - event RoutingDecision(uint256 indexed jobId, address indexed provider, uint256 amount, bytes32 routingHash)
    - event AgentUpdated(address indexed oldAgent, address indexed newAgent)

    Write the ABI in the standard JSON ABI format that viem expects, with `as const` assertion.

    Export TypeScript interfaces:
    ```typescript
    export interface Job {
      id: bigint;
      user: `0x${string}`;
      detailsHash: `0x${string}`;
      routingHash: `0x${string}`;
      provider: `0x${string}`;
      amount: bigint;
      isTracked: boolean;
      createdAt: bigint;
      routedAt: bigint;
    }

    export interface JobSubmittedEvent {
      jobId: bigint;
      user: `0x${string}`;
      detailsHash: `0x${string}`;
      isTracked: boolean;
    }

    export interface RoutingDecisionEvent {
      jobId: bigint;
      provider: `0x${string}`;
      amount: bigint;
      routingHash: `0x${string}`;
    }
    ```

    Export contract address:
    ```typescript
    // Update after deployment to ADI Testnet
    export const COMPUTE_ROUTER_ADDRESS = '' as `0x${string}`;
    ```

    ---

    **Create `offchain/src/lib/adi-chain.ts`:**

    Define the ADI Testnet chain for viem/wagmi using `defineChain` from viem:
    ```typescript
    import { defineChain } from 'viem'

    export const adiTestnet = defineChain({
      id: 99999,
      name: 'ADI Testnet',
      nativeCurrency: {
        name: 'ADI',
        symbol: 'ADI',
        decimals: 18,
      },
      rpcUrls: {
        default: {
          http: ['https://rpc.ab.testnet.adifoundation.ai'],
        },
      },
      testnet: true,
    })
    ```

    The chain ID 99999 and RPC URL are taken from the existing hardhat.config.ts and scripts/increment.ts which already use this chain successfully.

    ---

    **Update `offchain/src/lib/wagmi.ts`:**

    - Import `adiTestnet` from `./adi-chain`
    - Add `adiTestnet` to the `chains` array: `chains: [mainnet, sepolia, adiTestnet]`
    - Add HTTP transport for adiTestnet: `[adiTestnet.id]: http()`
    - Keep existing mainnet and sepolia config unchanged
    - Keep existing `injected()` connector

    The updated config should look like:
    ```typescript
    import { createConfig, http } from 'wagmi'
    import { mainnet, sepolia } from 'wagmi/chains'
    import { injected } from 'wagmi/connectors'
    import { adiTestnet } from './adi-chain'

    export const config = createConfig({
      chains: [mainnet, sepolia, adiTestnet],
      connectors: [
        injected(),
      ],
      transports: {
        [mainnet.id]: http(),
        [sepolia.id]: http(),
        [adiTestnet.id]: http(),
      },
    })

    export type WagmiConfig = typeof config
    ```

    **Create directory if needed:** `offchain/src/lib/contracts/` may not exist yet.
  </action>
  <verify>
    Run `cd /home/julius/Documents/necto/offchain && npx eslint src/lib/contracts/compute-router.ts src/lib/adi-chain.ts src/lib/wagmi.ts` — no lint errors.
    Verify the contracts directory and file exist: `ls offchain/src/lib/contracts/compute-router.ts`.
    Verify wagmi.ts imports adiTestnet correctly: `grep "adiTestnet" offchain/src/lib/wagmi.ts`.
  </verify>
  <done>
    TypeScript ABI exported as const for viem type inference. Job, JobSubmittedEvent, RoutingDecisionEvent interfaces match contract exactly. ADI Testnet chain defined with correct chain ID (99999) and RPC. wagmi.ts updated with ADI Testnet chain and transport. Contract address placeholder ready for post-deployment update. All files lint-clean.
  </done>
</task>

</tasks>

<verification>
**Contract Completeness:**
- [ ] ComputeRouter.sol compiles with solc ^0.8.28 via `npx hardhat compile`
- [ ] All required functions implemented: submitJob, recordRoutingDecision, getJob, updateAgent
- [ ] All required events defined: JobSubmitted, RoutingDecision, AgentUpdated
- [ ] onlyAgent modifier restricts writes to whitelisted agent address
- [ ] Tracked/untracked mode supported (isTracked bool, address(0) for untracked)
- [ ] Job struct includes all required fields per locked user decisions
- [ ] Double-routing prevention (routedAt == 0 check)
- [ ] Input validation on all write functions

**Test Coverage:**
- [ ] All tests pass via `npx hardhat test` in hardhat/ directory
- [ ] Deployment tests (correct agent, reject zero address)
- [ ] submitJob tests (tracked, untracked, events, counter, access control)
- [ ] recordRoutingDecision tests (success, events, all revert cases)
- [ ] getJob tests (submitted job, routed job, non-existent job)
- [ ] updateAgent tests (success, event, new agent works, reject zero)
- [ ] Integration lifecycle tests (full submit → route → read flow)

**Deployment Readiness:**
- [ ] Ignition module exists with parameterized agent address
- [ ] Interaction script follows established increment.ts pattern
- [ ] Deploy command documented in module comments

**Offchain Integration:**
- [ ] TypeScript ABI exported as `const` for viem type inference
- [ ] TypeScript interfaces match contract struct/events exactly
- [ ] ADI Testnet chain defined with correct chain ID and RPC
- [ ] wagmi.ts updated with ADI Testnet chain and transport
- [ ] Contract address placeholder ready for post-deployment update

**Security:**
- [ ] Only agent can call submitJob, recordRoutingDecision, updateAgent
- [ ] Job existence validated before routing
- [ ] Double-routing prevention
- [ ] Zero address validation on constructor and updateAgent
- [ ] No reentrancy risk (no external calls to untrusted contracts)

**User Decision Compliance (LOCKED):**
- [ ] Minimal on-chain data: job ID + hashes only (no full metadata stored)
- [ ] detailsHash and routingHash fields present (pointing to 0G Storage)
- [ ] Agent address whitelisted (onlyAgent modifier)
- [ ] Open read access (getJob is view, no access restriction)
- [ ] Tracked/untracked mode built in from day 1
- [ ] No escrow logic (deferred to Phase 3)
- [ ] No pausable/emergency controls (deferred to Phase 3)
- [ ] No on-chain provider registry (deferred to Phase 3)
</verification>

<success_criteria>
1. **Contract Code:** ComputeRouter.sol compiles, implements submitJob/recordRoutingDecision/getJob/updateAgent
2. **Event Emission:** JobSubmitted and RoutingDecision events fire with correct indexed params
3. **Access Control:** Only whitelisted agent can write; anyone can read
4. **Privacy:** Untracked jobs store address(0) regardless of input user address
5. **Test Suite:** All tests pass via `npx hardhat test` using viem + node:test pattern
6. **Deployment:** Ignition module ready with parameterized agent address
7. **Integration:** TypeScript ABI/types in offchain/src/lib/contracts/ match contract interface
8. **Chain Config:** ADI Testnet (chain 99999) configured in wagmi.ts with transport
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-agent/01-01-SUMMARY.md`
</output>
