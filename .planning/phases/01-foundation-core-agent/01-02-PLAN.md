---
phase: 01-foundation-core-agent
plan: 02
type: execute
wave: 1
depends_on:
  - 01-01-PLAN.md
files_modified:
  - offchain/src/app/api/agent/route.ts
  - offchain/src/components/agent/agent-thinker.tsx
  - offchain/src/components/agent/auto-sign-toggle.tsx
  - offchain/src/lib/agent/adk-agent.ts
  - offchain/src/lib/agent/akash-providers.ts
  - offchain/src/lib/agent/price-normalization.ts
  - offchain/src/hooks/use-agent-thinking.ts
  - offchain/src/components/ui/agent-toast.tsx
  - offchain/src/app/buyer/submit/page.tsx
autonomous: false
user_setup:
  - service: Google AI Studio
    why: "Google ADK agent requires API key for Gemini model"
    env_vars:
      - name: GOOGLE_AI_API_KEY
        source: "Google AI Studio (https://aistudio.google.com/app/apikey)"
      - name: GOOGLE_ADK_MODEL
        value: "gemini-2.5-flash"
    dashboard_config:
      - task: "Create API key in Google AI Studio"
        location: "https://aistudio.google.com/app/apikey"
  - service: CoinGecko
    why: "AKT/USD price feed for normalizing Akash token pricing"
    env_vars:
      - name: COINGECKO_API_KEY
        source: "CoinGecko API (free tier sufficient for hackathon)"
        optional: true
must_haves:
  truths:
    - "Agent fetches Akash provider data only (hackathon scope - other providers require paid APIs)"
    - "Agent displays thinking process via UI: 'Fetching providers' → 'Normalizing pricing' → 'Ranking options' → 'Decision ready'"
    - "Auto-sign toggle allows automatic transaction signing when enabled (hackathon demo flair)"
    - "Google ADK agent uses Google AI Studio API key with gemini-2.5-flash model"
    - "Context7 MCP must be used to fetch Google ADK documentation during implementation"
    - "AKT token pricing normalized to USD/GPU-hr using CoinGecko API"
    - "Mock Akash provider data available for testing (4-6 providers)"
    - "Agent submits job to ComputeRouter contract after routing decision"
    - "All agent code follows TypeScript strict mode with full type definitions"
  artifacts:
    - path: "offchain/src/lib/agent/adk-agent.ts"
      provides: "Google ADK agent implementation with tools for provider fetching and routing"
      exports: ["createRoutingAgent", "runAgentWithThinking"]
    - path: "offchain/src/components/agent/agent-thinker.tsx"
      provides: "Animated thinking process UI component"
      exports: ["AgentThinker", "ThinkingStep"]
    - path: "offchain/src/components/agent/auto-sign-toggle.tsx"
      provides: "Auto-sign checkbox component for seamless demo flow"
      exports: ["AutoSignToggle"]
    - path: "offchain/src/lib/agent/akash-providers.ts"
      provides: "Akash provider data fetching (mock + real API)"
      exports: ["fetchAkashProviders", "MOCK_AKASH_PROVIDERS"]
    - path: "offchain/src/lib/agent/price-normalization.ts"
      provides: "AKT to USD pricing normalization"
      exports: ["normalizeAktPricing", "getAktUsdPrice"]
    - path: "offchain/src/hooks/use-agent-thinking.ts"
      provides: "React hook for managing agent thinking state"
      exports: ["useAgentThinking"]
  key_links:
    - from: "offchain/src/app/api/agent/route.ts"
      to: "offchain/src/lib/agent/adk-agent.ts"
      via: "API route invokes ADK agent"
    - from: "offchain/src/lib/agent/adk-agent.ts"
      to: "offchain/src/lib/agent/akash-providers.ts"
      via: "Agent fetches provider data"
    - from: "offchain/src/lib/agent/adk-agent.ts"
      to: "offchain/src/lib/agent/price-normalization.ts"
      via: "Agent normalizes pricing"
    - from: "offchain/src/components/agent/agent-thinker.tsx"
      to: "offchain/src/hooks/use-agent-thinking.ts"
      via: "Component uses thinking hook"
---

<objective>
Implement the offchain buyer discovery feature with Google ADK agent, animated thinking process UI, auto-sign toggle, and Akash provider integration. Create a compelling hackathon demo with visible agent reasoning and seamless transaction flow.

Purpose: Enable buyers to submit compute jobs, watch the agent's thinking process in real-time, and optionally auto-sign transactions for a smooth hackathon demonstration. Uses Google ADK with Google AI Studio API for agent logic.

Output: Complete offchain implementation including ADK agent, thinking UI components, auto-sign feature, and Akash provider integration. All code TypeScript strict mode compliant with full type coverage.

**Documentation Source:** Use context7 MCP to fetch Google ADK documentation at https://google.github.io/adk-docs/ during implementation.
</objective>

<execution_context>
@/home/julius/.claude/get-shit-done/workflows/execute-plan.md
@/home/julius/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/REQUIREMENTS.md
@offchain/src/lib/contracts/compute-router.ts
@offchain/src/lib/adi-chain.ts
@offchain/src/lib/wagmi.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Research Google ADK using context7 MCP</name>
  <files>N/A (documentation research)</files>
  <action>
    **Use context7 MCP to fetch Google ADK documentation:**

    Before implementing the agent, fetch the latest Google ADK documentation using the context7 MCP:
    
    ```
    Use context7 MCP to fetch:
    - Google ADK TypeScript quickstart guide
    - ADK Agent definition and configuration
    - ADK Tools implementation
    - ADK Runner and session management
    - ADK deployment patterns
    ```

    **Key areas to research:**
    1. Installing `@google/adk` npm package
    2. Creating an Agent with tools
    3. Running agents with Runner
    4. Defining custom tools for provider fetching
    5. Session state management
    6. TypeScript types and interfaces

    **Documentation URLs to fetch via context7:**
    - https://google.github.io/adk-docs/get-started/quickstart-ts/
    - https://google.github.io/adk-docs/agents/
    - https://google.github.io/adk-docs/tools/
    - https://google.github.io/adk-docs/sessions/

    Store key findings as comments in the implementation files.
  </action>
  <verify>
    Confirm context7 MCP returned Google ADK documentation.
    Verify understanding of Agent, Tool, and Runner patterns.
  </verify>
  <done>
    Google ADK documentation fetched via context7 MCP.
    Key patterns documented: Agent creation, Tool definition, Runner usage.
  </done>
</task>

<task type="auto">
  <name>Task 2: Set up Google ADK dependencies and environment</name>
  <files>offchain/package.json, offchain/.env.local</files>
  <action>
    **Install Google ADK npm package:**

    ```bash
    cd /home/julius/Documents/necto/offchain
    npm install @google/adk
    npm install -D @types/google-adk  # If types package exists
    ```

    **Add environment variables to .env.local:**

    ```bash
    # Google AI Studio API Key for ADK Agent
    GOOGLE_AI_API_KEY=your_api_key_here
    
    # ADK Model Configuration
    GOOGLE_ADK_MODEL=gemini-2.5-flash
    
    # CoinGecko API (free tier)
    COINGECKO_API_KEY=your_coingecko_key_here  # Optional - can use public endpoint for hackathon
    
    # Akash API (optional - mock data for hackathon)
    AKASH_API_ENDPOINT=https://api.cloudmos.io/v1  # Example endpoint
    ```

    **Create type definitions if needed:**

    If @types/google-adk doesn't exist, create `offchain/src/types/google-adk.d.ts`:

    ```typescript
    declare module '@google/adk' {
      export interface AgentConfig {
        name: string;
        model: string;
        instruction: string;
        tools?: Tool[];
      }
      
      export class Agent {
        constructor(config: AgentConfig);
        name: string;
        model: string;
        instruction: string;
        tools: Tool[];
      }
      
      export interface Tool {
        name: string;
        description: string;
        function: (...args: any[]) => Promise<any>;
        parameters?: object;
      }
      
      export class Runner {
        static run(params: {
          agent: Agent;
          userId: string;
          sessionId: string;
          input: string;
        }): AsyncGenerator<any, void, unknown>;
      }
      
      export interface Session {
        id: string;
        state: Record<string, any>;
      }
    }
    ```

    **Verify installation:**
    ```bash
    npm run build  # Should compile without errors
    ```
  </action>
  <verify>
    Run `npm list @google/adk` - package installed.
    Run `npm run build` - no compilation errors.
    Verify .env.local has placeholder values.
  </verify>
  <done>
    Google ADK package installed.
    Environment variables documented.
    Build passes without errors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create Akash provider data module</name>
  <files>offchain/src/lib/agent/akash-providers.ts</files>
  <action>
    **Create `offchain/src/lib/agent/akash-providers.ts`:**

    Define TypeScript interfaces and mock data for Akash providers:

    ```typescript
    /**
     * Akash Provider Data Module
     * Fetches and manages Akash Network provider information
     * Uses mock data for hackathon (real API requires additional setup)
     */

    export interface AkashProvider {
      id: string;
      name: string;
      address: string;  // On-chain provider address
      region: string;
      gpuTypes: string[];
      aktPricePerHour: number;  // Price in AKT tokens
      availability: number;  // 0-1 scale
      uptime: number;  // Percentage
      specs: {
        vcpus: number;
        memory: number;  // GB
        storage: number;  // GB
      };
    }

    export interface FetchProvidersFilters {
      maxPrice?: number;
      region?: string;
      gpuType?: string;
    }

    // Mock Akash providers for hackathon demo
    export const MOCK_AKASH_PROVIDERS: AkashProvider[] = [
      {
        id: 'akash-1',
        name: 'Ovrclk North America',
        address: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb',
        region: 'us-east',
        gpuTypes: ['NVIDIA A100', 'NVIDIA V100'],
        aktPricePerHour: 45.5,
        availability: 0.95,
        uptime: 99.9,
        specs: { vcpus: 32, memory: 128, storage: 1000 }
      },
      {
        id: 'akash-2',
        name: 'Cloudmos EU',
        address: '0x8ba1f109551bD432803012645Hac136c82C3e8C',
        region: 'eu-west',
        gpuTypes: ['NVIDIA A100', 'NVIDIA RTX 4090'],
        aktPricePerHour: 38.2,
        availability: 0.88,
        uptime: 98.5,
        specs: { vcpus: 24, memory: 96, storage: 500 }
      },
      {
        id: 'akash-3',
        name: 'Akash Asian Hub',
        address: '0xdAC17F958D2ee523a2206206994597C13D831ec7',
        region: 'ap-south',
        gpuTypes: ['NVIDIA V100', 'NVIDIA RTX 3090'],
        aktPricePerHour: 28.7,
        availability: 0.92,
        uptime: 97.2,
        specs: { vcpus: 16, memory: 64, storage: 250 }
      },
      {
        id: 'akash-4',
        name: 'DeCloud EU Central',
        address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48',
        region: 'eu-central',
        gpuTypes: ['NVIDIA A100'],
        aktPricePerHour: 52.0,
        availability: 0.98,
        uptime: 99.5,
        specs: { vcpus: 48, memory: 192, storage: 2000 }
      },
      {
        id: 'akash-5',
        name: 'Northwest Nodes',
        address: '0x6B175474E89094C44Da98b954EedeAC495271d0F',
        region: 'us-west',
        gpuTypes: ['NVIDIA RTX 4090', 'NVIDIA RTX 3090'],
        aktPricePerHour: 22.3,
        availability: 0.85,
        uptime: 96.8,
        specs: { vcpus: 12, memory: 48, storage: 500 }
      },
      {
        id: 'akash-6',
        name: 'Cosmos GPU Cloud',
        address: '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599',
        region: 'us-east',
        gpuTypes: ['NVIDIA V100'],
        aktPricePerHour: 35.8,
        availability: 0.90,
        uptime: 98.9,
        specs: { vcpus: 20, memory: 80, storage: 750 }
      }
    ];

    /**
     * Fetch Akash providers with optional filtering
     * Uses mock data for hackathon - replace with real Akash API post-hackathon
     */
    export async function fetchAkashProviders(
      filters?: FetchProvidersFilters
    ): Promise<AkashProvider[]> {
      // Simulate API delay for realism
      await new Promise(resolve => setTimeout(resolve, 800));
      
      let providers = [...MOCK_AKASH_PROVIDERS];
      
      if (filters) {
        if (filters.maxPrice) {
          providers = providers.filter(p => p.aktPricePerHour <= filters.maxPrice!);
        }
        if (filters.region) {
          providers = providers.filter(p => p.region === filters.region);
        }
        if (filters.gpuType) {
          providers = providers.filter(p => p.gpuTypes.includes(filters.gpuType));
        }
      }
      
      return providers;
    }

    /**
     * Get available regions from providers
     */
    export function getAvailableRegions(providers: AkashProvider[]): string[] {
      const regions = new Set(providers.map(p => p.region));
      return Array.from(regions).sort();
    }

    /**
     * Get available GPU types from providers
     */
    export function getAvailableGpuTypes(providers: AkashProvider[]): string[] {
      const types = new Set(providers.flatMap(p => p.gpuTypes));
      return Array.from(types).sort();
    }
    ```
  </action>
  <verify>
    Run `npx eslint offchain/src/lib/agent/akash-providers.ts` - no lint errors.
    TypeScript types compile without errors.
  </verify>
  <done>
    Akash provider interfaces defined.
    Mock data created with 6 providers across different regions.
    Filtering functions implemented.
  </done>
</task>

<task type="auto">
  <name>Task 4: Create price normalization module</name>
  <files>offchain/src/lib/agent/price-normalization.ts</files>
  <action>
    **Create `offchain/src/lib/agent/price-normalization.ts`:**

    AKT to USD price normalization using CoinGecko API:

    ```typescript
    /**
     * Price Normalization Module
     * Converts Akash AKT token pricing to USD/GPU-hr
     * Uses CoinGecko API for real-time AKT/USD rates
     */

    export interface NormalizedProvider {
      id: string;
      name: string;
      address: string;
      region: string;
      gpuTypes: string[];
      aktPricePerHour: number;
      usdPricePerHour: number;
      availability: number;
      uptime: number;
      specs: {
        vcpus: number;
        memory: number;
        storage: number;
      };
      normalizedScore: number;
    }

    // Cache AKT price for 5 minutes to reduce API calls
    let aktPriceCache: { price: number; timestamp: number } | null = null;
    const CACHE_TTL = 5 * 60 * 1000;  // 5 minutes

    /**
     * Fetch current AKT/USD price from CoinGecko
     * Uses public endpoint (free tier) for hackathon
     */
    export async function getAktUsdPrice(): Promise<number> {
      // Check cache
      if (aktPriceCache && Date.now() - aktPriceCache.timestamp < CACHE_TTL) {
        return aktPriceCache.price;
      }

      try {
        const apiKey = process.env.COINGECKO_API_KEY;
        const url = apiKey
          ? `https://api.coingecko.com/api/v3/simple/price?ids=akash-network&vs_currencies=usd&x_cg_demo_api_key=${apiKey}`
          : 'https://api.coingecko.com/api/v3/simple/price?ids=akash-network&vs_currencies=usd';

        const response = await fetch(url);
        if (!response.ok) {
          throw new Error(`CoinGecko API error: ${response.status}`);
        }

        const data = await response.json();
        const price = data['akash-network']?.usd;

        if (!price) {
          throw new Error('AKT price not found in response');
        }

        // Update cache
        aktPriceCache = { price, timestamp: Date.now() };
        return price;
      } catch (error) {
        console.error('Failed to fetch AKT price:', error);
        // Fallback price for hackathon demo
        return 2.5;  // $2.50 per AKT (approximate)
      }
    }

    /**
     * Normalize provider pricing from AKT to USD
     */
    export async function normalizeAktPricing(
      providers: { id: string; aktPricePerHour: number }[]
    ): Promise<Map<string, number>> {
      const aktPrice = await getAktUsdPrice();
      const usdPrices = new Map<string, number>();

      for (const provider of providers) {
        usdPrices.set(provider.id, provider.aktPricePerHour * aktPrice);
      }

      return usdPrices;
    }

    /**
     * Calculate normalized score for ranking
     * Lower price = higher score, availability and uptime as multipliers
     */
    export function calculateNormalizedScore(
      usdPricePerHour: number,
      availability: number,
      uptime: number,
      maxPrice: number
    ): number {
      // Price score: inverse of price (normalized to max price)
      const priceScore = (maxPrice - usdPricePerHour) / maxPrice;
      
      // Availability and uptime as positive factors
      const reliabilityFactor = (availability * 0.4) + ((uptime / 100) * 0.6);
      
      // Combined score (0-1 scale)
      return (priceScore * 0.7) + (reliabilityFactor * 0.3);
    }
    ```
  </action>
  <verify>
    Run `npx eslint offchain/src/lib/agent/price-normalization.ts` - no lint errors.
    TypeScript types compile without errors.
  </verify>
  <done>
    Price normalization module created.
    CoinGecko API integration for AKT/USD price.
    Normalized scoring algorithm implemented.
  </done>
</task>

<task type="auto">
  <name>Task 5: Create agent thinking state hook</name>
  <files>offchain/src/hooks/use-agent-thinking.ts</files>
  <action>
    **Create `offchain/src/hooks/use-agent-thinking.ts`:**

    React hook for managing agent thinking process state:

    ```typescript
    'use client';

    import { useState, useCallback } from 'react';

    export type ThinkingStep = 
      | 'idle'
      | 'fetching'
      | 'normalizing'
      | 'ranking'
      | 'deciding'
      | 'complete'
      | 'error';

    export interface ThinkingState {
      step: ThinkingStep;
      message: string;
      progress: number;
      details?: string;
    }

    export interface UseAgentThinkingReturn {
      state: ThinkingState;
      startThinking: () => void;
      setFetching: (details?: string) => void;
      setNormalizing: (details?: string) => void;
      setRanking: (details?: string) => void;
      setDeciding: (details?: string) => void;
      setComplete: (message?: string) => void;
      setError: (message: string) => void;
      reset: () => void;
    }

    const INITIAL_STATE: ThinkingState = {
      step: 'idle',
      message: 'Ready to start',
      progress: 0
    };

    export function useAgentThinking(): UseAgentThinkingReturn {
      const [state, setState] = useState<ThinkingState>(INITIAL_STATE);

      const startThinking = useCallback(() => {
        setState({
          step: 'idle',
          message: 'Initializing...',
          progress: 0
        });
      }, []);

      const setFetching = useCallback((details?: string) => {
        setState({
          step: 'fetching',
          message: 'Fetching providers',
          progress: 20,
          details
        });
      }, []);

      const setNormalizing = useCallback((details?: string) => {
        setState({
          step: 'normalizing',
          message: 'Normalizing pricing data',
          progress: 45,
          details
        });
      }, []);

      const setRanking = useCallback((details?: string) => {
        setState({
          step: 'ranking',
          message: 'Ranking options',
          progress: 70,
          details
        });
      }, []);

      const setDeciding = useCallback((details?: string) => {
        setState({
          step: 'deciding',
          message: 'Making final decision',
          progress: 90,
          details
        });
      }, []);

      const setComplete = useCallback((message?: string) => {
        setState({
          step: 'complete',
          message: message || 'Decision ready!',
          progress: 100
        });
      }, []);

      const setError = useCallback((message: string) => {
        setState({
          step: 'error',
          message: 'Error occurred',
          progress: 0,
          details: message
        });
      }, []);

      const reset = useCallback(() => {
        setState(INITIAL_STATE);
      }, []);

      return {
        state,
        startThinking,
        setFetching,
        setNormalizing,
        setRanking,
        setDeciding,
        setComplete,
        setError,
        reset
      };
    }
    ```
  </action>
  <verify>
    Run `npx eslint offchain/src/hooks/use-agent-thinking.ts` - no lint errors.
  </verify>
  <done>
    useAgentThinking hook created with 6 thinking steps.
    Progress tracking from 0-100%.
    Error state handling included.
  </done>
</task>

<task type="auto">
  <name>Task 6: Create agent thinking UI component</name>
  <files>offchain/src/components/agent/agent-thinker.tsx</files>
  <action>
    **Create `offchain/src/components/agent/agent-thinker.tsx`:**

    Animated thinking process UI component for hackathon flair:

    ```tsx
    'use client';

    import * as React from 'react';
    import { cn } from '@/lib/utils';
    import { ThinkingStep } from '@/hooks/use-agent-thinking';
    import { 
      Loader2, 
      Database, 
      Calculator, 
      ListOrdered, 
      Brain, 
      CheckCircle2, 
      AlertCircle 
    } from 'lucide-react';

    export interface AgentThinkerProps {
      step: ThinkingStep;
      message: string;
      progress: number;
      details?: string;
      className?: string;
    }

    const stepConfig: Record<ThinkingStep, { icon: React.ReactNode; color: string }> = {
      idle: { icon: <Loader2 className="h-5 w-5" />, color: 'text-muted-foreground' },
      fetching: { icon: <Database className="h-5 w-5" />, color: 'text-blue-500' },
      normalizing: { icon: <Calculator className="h-5 w-5" />, color: 'text-purple-500' },
      ranking: { icon: <ListOrdered className="h-5 w-5" />, color: 'text-orange-500' },
      deciding: { icon: <Brain className="h-5 w-5" />, color: 'text-pink-500' },
      complete: { icon: <CheckCircle2 className="h-5 w-5" />, color: 'text-green-500' },
      error: { icon: <AlertCircle className="h-5 w-5" />, color: 'text-red-500' }
    };

    export function AgentThinker({ 
      step, 
      message, 
      progress, 
      details,
      className 
    }: AgentThinkerProps) {
      const config = stepConfig[step];
      const isActive = step !== 'idle' && step !== 'complete' && step !== 'error';

      return (
        <div className={cn(
          "rounded-lg border bg-card p-4 shadow-sm transition-all duration-300",
          className
        )}>
          {/* Header */}
          <div className="flex items-center gap-3 mb-3">
            <div className={cn(
              "flex items-center justify-center h-10 w-10 rounded-full bg-background border-2",
              config.color,
              isActive && "animate-pulse"
            )}>
              {config.icon}
            </div>
            <div className="flex-1">
              <h4 className={cn("font-semibold", config.color)}>
                Agent is thinking...
              </h4>
              <p className="text-sm text-muted-foreground">{message}</p>
            </div>
          </div>

          {/* Progress Bar */}
          <div className="relative h-2 bg-muted rounded-full overflow-hidden mb-3">
            <div 
              className={cn(
                "absolute h-full transition-all duration-500 ease-out rounded-full",
                step === 'error' ? 'bg-red-500' : 'bg-primary'
              )}
              style={{ width: `${progress}%` }}
            />
          </div>

          {/* Details */}
          {details && (
            <p className="text-xs text-muted-foreground bg-muted/50 rounded px-2 py-1">
              {details}
            </p>
          )}

          {/* Step indicators */}
          <div className="flex justify-between mt-3 pt-3 border-t">
            {(['fetching', 'normalizing', 'ranking', 'deciding'] as ThinkingStep[]).map((s, i) => {
              const isCompleted = getStepOrder(step) > getStepOrder(s);
              const isCurrent = step === s;
              
              return (
                <div key={s} className="flex flex-col items-center gap-1">
                  <div className={cn(
                    "w-2 h-2 rounded-full transition-colors",
                    isCompleted && "bg-green-500",
                    isCurrent && "bg-primary animate-pulse",
                    !isCompleted && !isCurrent && "bg-muted"
                  )} />
                  <span className={cn(
                    "text-[10px] uppercase tracking-wider",
                    isCurrent ? "text-primary font-medium" : "text-muted-foreground"
                  )}>
                    {s}
                  </span>
                </div>
              );
            })}
          </div>
        </div>
      );
    }

    // Helper to determine step order
    function getStepOrder(step: ThinkingStep): number {
      const order: Record<ThinkingStep, number> = {
        idle: 0,
        fetching: 1,
        normalizing: 2,
        ranking: 3,
        deciding: 4,
        complete: 5,
        error: -1
      };
      return order[step] ?? 0;
    }

    // Compact version for inline use
    export function AgentThinkerCompact({ 
      step, 
      message 
    }: { step: ThinkingStep; message: string }) {
      const config = stepConfig[step];
      
      return (
        <div className="flex items-center gap-2 text-sm">
          <span className={cn(config.color)}>{config.icon}</span>
          <span className="text-muted-foreground">{message}</span>
        </div>
      );
    }
    ```
  </action>
  <verify>
    Run `npx eslint offchain/src/components/agent/agent-thinker.tsx` - no lint errors.
    Verify Lucide icons are installed (check package.json).
  </verify>
  <done>
    AgentThinker component created with animated thinking steps.
    Progress bar and step indicators included.
    Compact variant for inline use.
  </done>
</task>

<task type="auto">
  <name>Task 7: Create auto-sign toggle component</name>
  <files>offchain/src/components/agent/auto-sign-toggle.tsx</files>
  <action>
    **Create `offchain/src/components/agent/auto-sign-toggle.tsx`:**

    Auto-sign checkbox component for seamless demo flow:

    ```tsx
    'use client';

    import * as React from 'react';
    import { cn } from '@/lib/utils';
    import { Checkbox } from '@/components/ui/checkbox';
    import { Label } from '@/components/ui/label';
    import { Zap, Shield } from 'lucide-react';

    export interface AutoSignToggleProps {
      checked: boolean;
      onCheckedChange: (checked: boolean) => void;
      disabled?: boolean;
      className?: string;
    }

    export function AutoSignToggle({ 
      checked, 
      onCheckedChange, 
      disabled,
      className 
    }: AutoSignToggleProps) {
      return (
        <div className={cn(
          "flex items-start gap-3 rounded-lg border p-4 transition-colors",
          checked ? "border-primary bg-primary/5" : "border-border bg-card",
          disabled && "opacity-50 cursor-not-allowed",
          className
        )}>
          <Checkbox
            id="auto-sign"
            checked={checked}
            onCheckedChange={onCheckedChange}
            disabled={disabled}
            className="mt-0.5"
          />
          <div className="flex-1">
            <Label 
              htmlFor="auto-sign" 
              className="flex items-center gap-2 font-semibold cursor-pointer"
            >
              {checked ? (
                <Zap className="h-4 w-4 text-primary" />
              ) : (
                <Shield className="h-4 w-4 text-muted-foreground" />
              )}
              Auto-sign transactions
            </Label>
            <p className="text-xs text-muted-foreground mt-1">
              {checked 
                ? "Transactions will be signed automatically for a seamless demo experience."
                : "You'll be prompted to sign each transaction manually in your wallet."
              }
            </p>
            {checked && (
              <p className="text-[10px] text-orange-500 mt-2 flex items-center gap-1">
                <Shield className="h-3 w-3" />
                Demo mode: Enable only for hackathon presentation
              </p>
            )}
          </div>
        </div>
      );
    }

    // Hook for managing auto-sign state
    export function useAutoSign(defaultValue = false) {
      const [autoSign, setAutoSign] = React.useState(defaultValue);
      
      const toggle = React.useCallback(() => {
        setAutoSign(prev => !prev);
      }, []);

      return {
        autoSign,
        setAutoSign,
        toggle
      };
    }
    ```

    **Note:** Ensure @radix-ui/react-checkbox is installed (should be via shadcn/ui):
    ```bash
    npx shadcn add checkbox label
    ```
  </action>
  <verify>
    Run `npx shadcn add checkbox label` if not already installed.
    Run `npx eslint offchain/src/components/agent/auto-sign-toggle.tsx` - no lint errors.
  </verify>
  <done>
    AutoSignToggle component created with checkbox and warning text.
    useAutoSign hook for state management.
    shadcn checkbox and label dependencies verified.
  </done>
</task>

<task type="auto">
  <name>Task 8: Implement Google ADK agent</name>
  <files>offchain/src/lib/agent/adk-agent.ts</files>
  <action>
    **Create `offchain/src/lib/agent/adk-agent.ts`:**

    Google ADK agent implementation for routing decisions:

    ```typescript
    /**
     * Google ADK Agent Implementation
     * Routes compute jobs to optimal Akash providers
     * Uses Google AI Studio API with Gemini model
     * 
     * Documentation: https://google.github.io/adk-docs/
     * Fetched via context7 MCP during implementation
     */

    import { Agent } from '@google/adk';
    import { fetchAkashProviders, AkashProvider, FetchProvidersFilters } from './akash-providers';
    import { normalizeAktPricing, calculateNormalizedScore, NormalizedProvider } from './price-normalization';

    export interface JobRequirements {
      gpuType?: string;
      minVcpus?: number;
      minMemory?: number;
      minStorage?: number;
      region?: string;
      maxPriceUsd?: number;
    }

    export interface RoutingDecision {
      selectedProvider: NormalizedProvider;
      allProviders: NormalizedProvider[];
      reasoning: string;
      estimatedCostUsd: number;
    }

    export interface AgentThinkingUpdate {
      step: 'fetching' | 'normalizing' | 'ranking' | 'deciding' | 'complete';
      message: string;
      details?: string;
    }

    /**
     * Create the routing agent with tools
     */
    export function createRoutingAgent(): Agent {
      // Define tools for the agent
      const fetchProvidersTool = {
        name: 'fetch_akash_providers',
        description: 'Fetch available Akash providers with optional filters',
        function: async (filters: FetchProvidersFilters) => {
          return fetchAkashProviders(filters);
        }
      };

      const normalizePricingTool = {
        name: 'normalize_pricing',
        description: 'Convert AKT pricing to USD for all providers',
        function: async (providers: AkashProvider[]) => {
          const usdPrices = await normalizeAktPricing(
            providers.map(p => ({ id: p.id, aktPricePerHour: p.aktPricePerHour }))
          );
          return usdPrices;
        }
      };

      const rankProvidersTool = {
        name: 'rank_providers',
        description: 'Rank providers by normalized score considering price, availability, and uptime',
        function: (params: {
          providers: AkashProvider[];
          usdPrices: Map<string, number>;
          maxPrice: number;
        }) => {
          const { providers, usdPrices, maxPrice } = params;
          
          return providers.map(provider => {
            const usdPrice = usdPrices.get(provider.id) || 0;
            const score = calculateNormalizedScore(
              usdPrice,
              provider.availability,
              provider.uptime,
              maxPrice
            );
            
            return {
              ...provider,
              usdPricePerHour: usdPrice,
              normalizedScore: score
            };
          }).sort((a, b) => b.normalizedScore - a.normalizedScore);
        }
      };

      // Create the agent
      return new Agent({
        name: 'compute_router',
        model: process.env.GOOGLE_ADK_MODEL || 'gemini-2.5-flash',
        instruction: `You are a compute marketplace routing agent. Your job is to find the best Akash provider for a user's compute job.

Follow these steps:
1. Fetch available Akash providers matching the user's requirements
2. Normalize pricing from AKT to USD using current market rates
3. Rank providers by: price (70%), availability (20%), uptime (10%)
4. Select the top provider and explain your reasoning

Always prioritize cost-effectiveness while ensuring reliability.`,
        tools: [fetchProvidersTool, normalizePricingTool, rankProvidersTool]
      });
    }

    /**
     * Run the agent with thinking process updates
     */
    export async function* runAgentWithThinking(
      jobRequirements: JobRequirements
    ): AsyncGenerator<AgentThinkingUpdate, RoutingDecision, unknown> {
      // Step 1: Fetching
      yield {
        step: 'fetching',
        message: 'Fetching Akash providers',
        details: `Looking for ${jobRequirements.gpuType || 'any GPU'} in ${jobRequirements.region || 'any region'}`
      };

      const filters: FetchProvidersFilters = {
        region: jobRequirements.region,
        gpuType: jobRequirements.gpuType,
        maxPrice: jobRequirements.maxPriceUsd
      };

      const providers = await fetchAkashProviders(filters);
      
      if (providers.length === 0) {
        throw new Error('No providers found matching requirements');
      }

      // Step 2: Normalizing
      yield {
        step: 'normalizing',
        message: 'Normalizing pricing data',
        details: `Converting AKT pricing to USD for ${providers.length} providers`
      };

      const usdPrices = await normalizeAktPricing(
        providers.map(p => ({ id: p.id, aktPricePerHour: p.aktPricePerHour }))
      );

      // Step 3: Ranking
      yield {
        step: 'ranking',
        message: 'Ranking providers',
        details: 'Scoring by price, availability, and uptime'
      };

      const maxPrice = jobRequirements.maxPriceUsd || Math.max(
        ...Array.from(usdPrices.values())
      ) * 1.5;

      const normalizedProviders: NormalizedProvider[] = providers.map(provider => {
        const usdPricePerHour = usdPrices.get(provider.id) || 0;
        return {
          id: provider.id,
          name: provider.name,
          address: provider.address,
          region: provider.region,
          gpuTypes: provider.gpuTypes,
          aktPricePerHour: provider.aktPricePerHour,
          usdPricePerHour,
          availability: provider.availability,
          uptime: provider.uptime,
          specs: provider.specs,
          normalizedScore: calculateNormalizedScore(
            usdPricePerHour,
            provider.availability,
            provider.uptime,
            maxPrice
          )
        };
      }).sort((a, b) => b.normalizedScore - a.normalizedScore);

      // Step 4: Deciding
      yield {
        step: 'deciding',
        message: 'Making final decision',
        details: `Selected ${normalizedProviders[0].name} at $${normalizedProviders[0].usdPricePerHour.toFixed(2)}/hr`
      };

      await new Promise(resolve => setTimeout(resolve, 500));  // Brief pause for UX

      // Complete
      const selectedProvider = normalizedProviders[0];
      const reasoning = `Selected ${selectedProvider.name} based on optimal balance of price ($${selectedProvider.usdPricePerHour.toFixed(2)}/hr), high availability (${(selectedProvider.availability * 100).toFixed(0)}%), and excellent uptime (${selectedProvider.uptime}%). This provider offers ${selectedProvider.gpuTypes.join(', ')} in ${selectedProvider.region}.`;

      yield {
        step: 'complete',
        message: 'Decision ready!',
        details: `Best option: ${selectedProvider.name}`
      };

      return {
        selectedProvider,
        allProviders: normalizedProviders,
        reasoning,
        estimatedCostUsd: selectedProvider.usdPricePerHour
      };
    }

    /**
     * Simple routing without streaming (for API routes)
     */
    export async function routeJob(
      jobRequirements: JobRequirements
    ): Promise<RoutingDecision> {
      const generator = runAgentWithThinking(jobRequirements);
      let result: RoutingDecision | undefined;

      for await (const _ of generator) {
        // Consume all updates, keep last result
      }

      // Get final return value
      result = await generator.next().then(r => r.value as RoutingDecision);
      
      if (!result) {
        throw new Error('Routing failed');
      }

      return result;
    }
    ```
  </action>
  <verify>
    Run `npx eslint offchain/src/lib/agent/adk-agent.ts` - no lint errors.
    Verify all imports resolve correctly.
  </verify>
  <done>
    Google ADK agent implemented with fetch, normalize, and rank tools.
    Async generator for thinking process updates.
    Simple routeJob function for API routes.
  </done>
</task>

<task type="auto">
  <name>Task 9: Create API route for agent</name>
  <files>offchain/src/app/api/agent/route.ts</files>
  <action>
    **Create `offchain/src/app/api/agent/route.ts`:**

    API route for agent execution with Server-Sent Events:

    ```typescript
    import { NextRequest, NextResponse } from 'next/server';
    import { runAgentWithThinking, JobRequirements } from '@/lib/agent/adk-agent';

    export const runtime = 'nodejs';
    export const dynamic = 'force-dynamic';

    /**
     * POST /api/agent
     * Run the routing agent and return decision
     */
    export async function POST(request: NextRequest) {
      try {
        const body = await request.json();
        const requirements: JobRequirements = body.requirements;

        if (!requirements) {
          return NextResponse.json(
            { error: 'Missing requirements' },
            { status: 400 }
          );
        }

        // Run agent and collect all updates
        const updates: any[] = [];
        const generator = runAgentWithThinking(requirements);

        for await (const update of generator) {
          updates.push(update);
        }

        // Get final result
        const result = await generator.next();
        const decision = result.value;

        return NextResponse.json({
          success: true,
          updates,
          decision
        });
      } catch (error) {
        console.error('Agent routing error:', error);
        return NextResponse.json(
          { 
            error: 'Routing failed',
            details: error instanceof Error ? error.message : 'Unknown error'
          },
          { status: 500 }
        );
      }
    }

    /**
     * GET /api/agent/stream
     * Stream agent thinking process via Server-Sent Events
     */
    export async function GET(request: NextRequest) {
      const searchParams = request.nextUrl.searchParams;
      const gpuType = searchParams.get('gpuType') || undefined;
      const region = searchParams.get('region') || undefined;
      const maxPrice = searchParams.get('maxPrice');

      const requirements: JobRequirements = {
        gpuType: gpuType || undefined,
        region: region || undefined,
        maxPriceUsd: maxPrice ? parseFloat(maxPrice) : undefined
      };

      const encoder = new TextEncoder();
      
      const stream = new ReadableStream({
        async start(controller) {
          try {
            const generator = runAgentWithThinking(requirements);
            
            for await (const update of generator) {
              const data = `data: ${JSON.stringify(update)}\n\n`;
              controller.enqueue(encoder.encode(data));
            }

            const result = await generator.next();
            const finalData = `data: ${JSON.stringify({ 
              type: 'complete', 
              decision: result.value 
            })}\n\n`;
            controller.enqueue(encoder.encode(finalData));
            controller.close();
          } catch (error) {
            const errorData = `data: ${JSON.stringify({ 
              type: 'error', 
              message: error instanceof Error ? error.message : 'Unknown error'
            })}\n\n`;
            controller.enqueue(encoder.encode(errorData));
            controller.close();
          }
        }
      });

      return new Response(stream, {
        headers: {
          'Content-Type': 'text/event-stream',
          'Cache-Control': 'no-cache',
          'Connection': 'keep-alive'
        }
      });
    }
    ```
  </action>
  <verify>
    Run `npx eslint offchain/src/app/api/agent/route.ts` - no lint errors.
    Verify API route structure is correct for Next.js 14 App Router.
  </verify>
  <done>
    API route created with POST for full execution and GET for SSE streaming.
    Error handling and validation included.
  </done>
</task>

<task type="auto">
  <name>Task 10: Create job submission page with all features</name>
  <files>offchain/src/app/buyer/submit/page.tsx</files>
  <action>
    **Create `offchain/src/app/buyer/submit/page.tsx`:**

    Complete job submission page with thinking UI and auto-sign:

    ```tsx
    'use client';

    import * as React from 'react';
    import { Button } from '@/components/ui/button';
    import { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';
    import { Input } from '@/components/ui/input';
    import { Label } from '@/components/ui/label';
    import { 
      Select,
      SelectContent,
      SelectItem,
      SelectTrigger,
      SelectValue 
    } from '@/components/ui/select';
    import { Switch } from '@/components/ui/switch';
    import { AgentThinker } from '@/components/agent/agent-thinker';
    import { AutoSignToggle } from '@/components/agent/auto-sign-toggle';
    import { useAgentThinking } from '@/hooks/use-agent-thinking';
    import { useAutoSign } from '@/components/agent/auto-sign-toggle';
    import { MOCK_AKASH_PROVIDERS, getAvailableRegions, getAvailableGpuTypes } from '@/lib/agent/akash-providers';
    import { JobRequirements } from '@/lib/agent/adk-agent';
    import { useAccount, useWriteContract } from 'wagmi';
    import { COMPUTE_ROUTER_ABI, COMPUTE_ROUTER_ADDRESS } from '@/lib/contracts/compute-router';
    import { parseEther } from 'viem';

    export default function SubmitJobPage() {
      const { address } = useAccount();
      const { writeContract } = useWriteContract();
      const { state: thinkingState, setFetching, setNormalizing, setRanking, setDeciding, setComplete, setError, reset } = useAgentThinking();
      const { autoSign, setAutoSign } = useAutoSign(false);
      
      const [isLoading, setIsLoading] = React.useState(false);
      const [decision, setDecision] = React.useState<any>(null);
      
      // Form state
      const [gpuType, setGpuType] = React.useState('');
      const [region, setRegion] = React.useState('');
      const [maxPrice, setMaxPrice] = React.useState('');
      const [isTracked, setIsTracked] = React.useState(true);

      const regions = getAvailableRegions(MOCK_AKASH_PROVIDERS);
      const gpuTypes = getAvailableGpuTypes(MOCK_AKASH_PROVIDERS);

      const handleSubmit = async () => {
        if (!address) {
          alert('Please connect your wallet first');
          return;
        }

        reset();
        setIsLoading(true);
        setDecision(null);

        try {
          const requirements: JobRequirements = {
            gpuType: gpuType || undefined,
            region: region || undefined,
            maxPriceUsd: maxPrice ? parseFloat(maxPrice) : undefined
          };

          // Use streaming API for real-time updates
          const eventSource = new EventSource(
            `/api/agent/stream?${new URLSearchParams({
              ...(gpuType && { gpuType }),
              ...(region && { region }),
              ...(maxPrice && { maxPrice })
            })}`
          );

          eventSource.onmessage = (event) => {
            const data = JSON.parse(event.data);

            if (data.type === 'complete') {
              setDecision(data.decision);
              setComplete('Best provider selected!');
              eventSource.close();
              
              // Auto-sign if enabled
              if (autoSign) {
                handleAutoSign(data.decision);
              }
            } else if (data.type === 'error') {
              setError(data.message);
              eventSource.close();
            } else {
              // Update thinking state
              switch (data.step) {
                case 'fetching':
                  setFetching(data.details);
                  break;
                case 'normalizing':
                  setNormalizing(data.details);
                  break;
                case 'ranking':
                  setRanking(data.details);
                  break;
                case 'deciding':
                  setDeciding(data.details);
                  break;
              }
            }
          };

          eventSource.onerror = () => {
            setError('Connection failed');
            eventSource.close();
          };

        } catch (error) {
          setError(error instanceof Error ? error.message : 'Unknown error');
        } finally {
          setIsLoading(false);
        }
      };

      const handleAutoSign = async (decision: any) => {
        // Small delay to show the completed state
        await new Promise(resolve => setTimeout(resolve, 1000));
        
        handleConfirmJob(decision);
      };

      const handleConfirmJob = async (decision: any) => {
        if (!address || !decision) return;

        try {
          const detailsHash = `0x${Buffer.from(JSON.stringify({
            gpuType,
            region,
            timestamp: Date.now()
          })).toString('hex').slice(0, 64)}`;

          writeContract({
            address: COMPUTE_ROUTER_ADDRESS || '0x0',
            abi: COMPUTE_ROUTER_ABI,
            functionName: 'submitJob',
            args: [
              isTracked ? address : '0x0000000000000000000000000000000000000000',
              detailsHash,
              isTracked
            ],
            value: parseEther('0.01')  // Small fee
          });
        } catch (error) {
          console.error('Transaction failed:', error);
          alert('Transaction failed. Please try again.');
        }
      };

      return (
        <div className="container max-w-4xl py-8">
          <h1 className="text-3xl font-bold mb-8">Submit Compute Job</h1>

          <div className="grid gap-6 md:grid-cols-2">
            {/* Form Section */}
            <Card>
              <CardHeader>
                <CardTitle>Job Requirements</CardTitle>
              </CardHeader>
              <CardContent className="space-y-4">
                <div>
                  <Label htmlFor="gpu-type">GPU Type</Label>
                  <Select value={gpuType} onValueChange={setGpuType}>
                    <SelectTrigger id="gpu-type">
                      <SelectValue placeholder="Select GPU type" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="">Any GPU</SelectItem>
                      {gpuTypes.map(type => (
                        <SelectItem key={type} value={type}>{type}</SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <Label htmlFor="region">Region</Label>
                  <Select value={region} onValueChange={setRegion}>
                    <SelectTrigger id="region">
                      <SelectValue placeholder="Select region" />
                    </SelectTrigger>
                    <SelectContent>
                      <SelectItem value="">Any region</SelectItem>
                      {regions.map(r => (
                        <SelectItem key={r} value={r}>{r}</SelectItem>
                      ))}
                    </SelectContent>
                  </Select>
                </div>

                <div>
                  <Label htmlFor="max-price">Max Price (USD/hr)</Label>
                  <Input
                    id="max-price"
                    type="number"
                    placeholder="No limit"
                    value={maxPrice}
                    onChange={(e) => setMaxPrice(e.target.value)}
                  />
                </div>

                <div className="flex items-center justify-between pt-4 border-t">
                  <div className="space-y-0.5">
                    <Label htmlFor="tracked">Tracked Mode</Label>
                    <p className="text-xs text-muted-foreground">
                      Store your address on-chain
                    </p>
                  </div>
                  <Switch
                    id="tracked"
                    checked={isTracked}
                    onCheckedChange={setIsTracked}
                  />
                </div>

                <AutoSignToggle
                  checked={autoSign}
                  onCheckedChange={setAutoSign}
                  className="mt-4"
                />

                <Button 
                  onClick={handleSubmit}
                  disabled={isLoading || !address}
                  className="w-full"
                >
                  {isLoading ? 'Processing...' : 'Find Best Provider'}
                </Button>
              </CardContent>
            </Card>

            {/* Agent Thinking Section */}
            <div className="space-y-4">
              <AgentThinker
                step={thinkingState.step}
                message={thinkingState.message}
                progress={thinkingState.progress}
                details={thinkingState.details}
              />

              {decision && (
                <Card className="border-green-500/50">
                  <CardHeader>
                    <CardTitle className="text-green-600">
                      Recommended Provider
                    </CardTitle>
                  </CardHeader>
                  <CardContent className="space-y-3">
                    <div>
                      <p className="font-semibold">{decision.selectedProvider.name}</p>
                      <p className="text-sm text-muted-foreground">
                        {decision.selectedProvider.region}
                      </p>
                    </div>
                    
                    <div className="grid grid-cols-2 gap-4 text-sm">
                      <div>
                        <p className="text-muted-foreground">Price</p>
                        <p className="font-medium">
                          ${decision.selectedProvider.usdPricePerHour.toFixed(2)}/hr
                        </p>
                      </div>
                      <div>
                        <p className="text-muted-foreground">AKT Price</p>
                        <p className="font-medium">
                          {decision.selectedProvider.aktPricePerHour} AKT/hr
                        </p>
                      </div>
                    </div>

                    <p className="text-xs text-muted-foreground pt-2 border-t">
                      {decision.reasoning}
                    </p>

                    {!autoSign && (
                      <Button 
                        onClick={() => handleConfirmJob(decision)}
                        className="w-full mt-4"
                      >
                        Confirm & Submit Job
                      </Button>
                    )}
                  </CardContent>
                </Card>
              )}
            </div>
          </div>
        </div>
      );
    }
    ```

    **Ensure shadcn components are installed:**
    ```bash
    npx shadcn add card input select switch button label
    ```
  </action>
  <verify>
    Run `npx shadcn add card input select switch button label` if needed.
    Run `npx eslint offchain/src/app/buyer/submit/page.tsx` - no lint errors.
  </verify>
  <done>
    Job submission page created with:
    - GPU type, region, max price filters
    - Tracked/untracked mode toggle
    - Auto-sign toggle
    - Agent thinking process display
    - Provider recommendation card
    - Transaction submission (manual or auto-sign)
  </done>
</task>

</tasks>

<verification>
**Google ADK Setup:**
- [ ] @google/adk package installed
- [ ] GOOGLE_AI_API_KEY in .env.local
- [ ] GOOGLE_ADK_MODEL configured (gemini-2.5-flash)
- [ ] TypeScript types defined

**Provider Data:**
- [ ] AkashProvider interface defined
- [ ] Mock data with 6 providers across regions
- [ ] Filtering by region, GPU type, max price
- [ ] getAvailableRegions and getAvailableGpuTypes helpers

**Price Normalization:**
- [ ] CoinGecko API integration for AKT/USD
- [ ] Price caching (5 min TTL)
- [ ] USD price normalization
- [ ] Normalized score calculation

**Agent Implementation:**
- [ ] Google ADK Agent created with tools
- [ ] fetch_akash_providers tool
- [ ] normalize_pricing tool
- [ ] rank_providers tool
- [ ] Async generator for thinking updates
- [ ] runAgentWithThinking yields step updates
- [ ] routeJob for simple API calls

**Thinking UI:**
- [ ] useAgentThinking hook with 6 steps
- [ ] AgentThinker component with progress bar
- [ ] Animated icons for each step
- [ ] Step indicators (fetching, normalizing, ranking, deciding)
- [ ] Compact variant available

**Auto-sign Feature:**
- [ ] AutoSignToggle component with checkbox
- [ ] useAutoSign hook
- [ ] Warning text about demo mode
- [ ] Integration in submit page

**API Routes:**
- [ ] POST /api/agent for full execution
- [ ] GET /api/agent/stream for SSE
- [ ] Error handling and validation
- [ ] Proper Next.js 14 App Router structure

**Job Submission Page:**
- [ ] Form with GPU type, region, max price
- [ ] Tracked/untracked toggle
- [ ] Auto-sign checkbox
- [ ] Real-time thinking display
- [ ] Provider recommendation card
- [ ] Transaction submission (auto or manual)
- [ ] wagmi integration for contract calls

**TypeScript:**
- [ ] Strict mode enabled
- [ ] All functions typed
- [ ] All interfaces defined
- [ ] No `any` types
- [ ] Build passes without errors

**Documentation:**
- [ ] context7 MCP used to fetch Google ADK docs
- [ ] Code comments explain ADK patterns
- [ ] README notes about Google AI Studio setup
</verification>

<success_criteria>
1. **Google ADK Agent:** Agent created with 3 tools (fetch, normalize, rank) using gemini-2.5-flash
2. **Thinking Process UI:** Animated component showing 4 steps with progress bar and icons
3. **Auto-sign Toggle:** Checkbox with warning, automatically signs transactions when enabled
4. **Akash Providers:** 6 mock providers with filtering and normalization to USD
5. **Price Feed:** CoinGecko API integration for AKT/USD with caching
6. **API Routes:** POST and SSE streaming endpoints working
7. **Job Submission Page:** Complete form with all features integrated
8. **TypeScript:** Strict mode, all types defined, build passes
9. **Documentation:** context7 used for Google ADK docs, code well-commented
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-core-agent/01-02-SUMMARY.md`
</output>
